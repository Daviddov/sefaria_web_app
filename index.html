<!DOCTYPE html>
<html dir="rtl" lang="he">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ניווט ספריא </title>
    <link rel="stylesheet" href="styles.css">

</head>

<body>
    <div class="container">
        <div class="header">
            <h1>🏛️ ניווט ספריא</h1>
            <p>נווט בספרי הקודש בחר טקסטים ומפרשים</p>
        </div>

        <!-- שלב 1: ניווט לקטגוריות -->
        <div id="categoriesStep" class="step">
            <div class="breadcrumb" id="breadcrumb">📍 דף הבית</div>

            <div class="nav-buttons">
                <button class="btn" id="backBtn" disabled>🔙 חזור</button>
                <button class="btn" id="homeBtn">🏠 דף הבית</button>
            </div>

            <div id="contentArea">
                <div class="loading">טוען...</div>
            </div>
        </div>

        <!-- שלב 2: בחירת section (עבור ספרים מורכבים) -->
        <div id="sectionStep" class="step hidden">
            <div class="breadcrumb" id="sectionBreadcrumb">📍 בחירת חלק</div>

            <div class="nav-buttons">
                <button class="btn" id="backToBookFromSectionBtn">🔙 חזור לספר</button>
                <button class="btn" id="homeFromSectionBtn">🏠 דף הבית</button>
            </div>

            <div class="section">
                <h3>📖 ספר נבחר: <span id="selectedBookTitleSection"></span></h3>
                <h3>📑 בחר חלק:</h3>
                <select id="sectionSelect">
                    <option value="">בחר חלק...</option>
                </select>
            </div>
        </div>

        <!-- שלב 3: בחירת פרק -->
        <div id="chapterStep" class="step hidden">
            <div class="breadcrumb" id="chapterBreadcrumb">📍 בחירת פרק</div>

            <div class="nav-buttons">
                <button class="btn" id="backToSectionBtn">🔙 חזור לחלק</button>
                <button class="btn" id="backToBookBtn">🔙 חזור לספר</button>
                <button class="btn" id="homeFromChapterBtn">🏠 דף הבית</button>
            </div>

            <div class="section">
                <h3>📖 נבחר: <span id="selectedBookTitle"></span></h3>
                <h3 id="selectedSectionTitle" class="hidden">📑 חלק: <span id="selectedSectionName"></span></h3>
                <h3>🔢 בחר פרק:</h3>
                <select id="chapterSelect">
                    <option value="">בחר פרק...</option>
                </select>
            </div>
        </div>

        <!-- שלב 4: בחירת פיסקאות וגירסאות -->
        <div id="paragraphStep" class="step hidden">
            <div class="breadcrumb" id="paragraphBreadcrumb">📍 בחירת פיסקאות</div>

            <div class="nav-buttons">
                <button class="btn" id="backToChapterBtn">🔙 חזור לפרק</button>
                <button class="btn" id="homeFromParagraphBtn">🏠 דף הבית</button>
            </div>

            <div class="section">
                <h3>📄 פרק נבחר: <span id="selectedChapterTitle"></span></h3>

                <div class="paragraph-selector">
                    <div>
                        <label>פיסקא התחלה:</label>
                        <select id="startParagraph">
                            <option value="">בחר התחלה...</option>
                        </select>
                    </div>
                    <div>
                        <label>פיסקא סוף:</label>
                        <select id="endParagraph">
                            <option value="">בחר סוף...</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="section">
                <h3>📚 גירסאות נוספות:</h3>
                <div id="versionsContainer" class="checkbox-group">
                    <div>בחר פיסקאות תחילה</div>
                </div>
            </div>

            <div class="section">
                <h3>📝 מפרשים:</h3>
                <div id="commentariesContainer" class="checkbox-group">
                    <div>בחר פיסקאות תחילה</div>
                </div>
            </div>

            <button class="generate-btn" id="generateBtn" disabled>📄 יצור מסמך</button>
            <div class="loading hidden" id="generateLoading">מייצר מסמך...</div>
        </div>

        <!-- פאנל דיבוג -->
        <div class="section">
            <h3>🔧 דיבוג:</h3>
            <button class="btn" id="clearDebugBtn">🗑️ נקה</button>
            <div class="debug-panel" id="debugPanel">
                <div>📱 Application started</div>
            </div>
        </div>
    </div>

    <script>
        class SefariaNavigator {
            constructor() {
    this.baseUrl = 'https://www.sefaria.org/api';
    this.currentPath = [];
    this.currentBook = null;
    this.currentSection = null;
    this.currentChapter = null;
    this.bookData = null;
    this.chapterData = null;
    this.commentaryCache = new Map(); // חשוב שיהיה cache זה
    
    this.init();
}

            init() {
                this.log('🚀 Starting Sefaria Navigator...');
                this.setupEventListeners();
                this.loadCategories();
            }

            setupEventListeners() {
                // ניווט
                document.getElementById('backBtn').addEventListener('click', () => this.goBack());
                document.getElementById('homeBtn').addEventListener('click', () => this.goHome());
                document.getElementById('backToBookFromSectionBtn').addEventListener('click', () => this.backToBook());
                document.getElementById('homeFromSectionBtn').addEventListener('click', () => this.goHome());
                document.getElementById('backToSectionBtn').addEventListener('click', () => this.backToSection());
                document.getElementById('backToBookBtn').addEventListener('click', () => this.backToBook());
                document.getElementById('homeFromChapterBtn').addEventListener('click', () => this.goHome());
                document.getElementById('backToChapterBtn').addEventListener('click', () => this.backToChapter());
                document.getElementById('homeFromParagraphBtn').addEventListener('click', () => this.goHome());

                // בחירות
                document.getElementById('sectionSelect').addEventListener('change', () => this.onSectionSelect());
                document.getElementById('chapterSelect').addEventListener('change', () => this.onChapterSelect());
                document.getElementById('startParagraph').addEventListener('change', () => this.onParagraphRangeChange());
                document.getElementById('endParagraph').addEventListener('change', () => this.onParagraphRangeChange());

                // יצירת מסמך
                document.getElementById('generateBtn').addEventListener('click', () => this.generateDocument());

                // דיבוג
                document.getElementById('clearDebugBtn').addEventListener('click', () => this.clearDebug());
            }
goBack() {

    if (this.currentPath.length > 0) {
        this.currentPath.pop();
        if (this.currentPath.length === 0) {
            this.loadCategories();
        } else {
            const parent = this.currentPath[this.currentPath.length - 1];
            this.navigateToCategory(parent);
            this.currentPath.pop();
        }
        this.updateBreadcrumb();
        this.updateBackButton();
    } else {
    }
}


            goHome() {
                // איפוס כל הנתונים
                this.currentPath = [];
                this.currentBook = null;
                this.currentSection = null;
                this.currentChapter = null;

                // הסתרת כל הצעדים פרט לצעד הראשון
                document.getElementById('categoriesStep').classList.remove('hidden');
                document.getElementById('sectionStep').classList.add('hidden');
                document.getElementById('chapterStep').classList.add('hidden');
                document.getElementById('paragraphStep').classList.add('hidden');

                // טעינת הקטגוריות מחדש
                this.loadCategories();
                this.updateBreadcrumb();
                this.updateBackButton();

                this.log('🏠 חזרה לדף הבית');
            }

            backToBook() {
                // איפוס הסקשן הנוכחי
                this.currentSection = null;

                // הסתרת כל הצעדים מלבד צעד הקטגוריות
                document.getElementById('sectionStep').classList.add('hidden');
                document.getElementById('chapterStep').classList.add('hidden');
                document.getElementById('paragraphStep').classList.add('hidden');
                document.getElementById('categoriesStep').classList.remove('hidden');

                this.log('📖 חזרה לבחירת ספר');
            }

            backToSection() {
                // הסתרת צעדי הפרק והפיסקאות
                document.getElementById('chapterStep').classList.add('hidden');
                document.getElementById('paragraphStep').classList.add('hidden');

                // הצגת צעד הסקשן
                document.getElementById('sectionStep').classList.remove('hidden');

                this.log('📑 חזרה לבחירת סקשן');
            }

            backToChapter() {
                // הסתרת צעד הפיסקאות
                document.getElementById('paragraphStep').classList.add('hidden');

                // הצגת צעד הפרק
                document.getElementById('chapterStep').classList.remove('hidden');

                this.log('🔢 חזרה לבחירת פרק');
            }
            async loadCategories() {
                try {
                    this.log('📚 Loading categories...');
                    const response = await fetch(`${this.baseUrl}/index`);
                    const data = await response.json();

                    this.displayCategories(data);
                } catch (error) {
                    this.log(`❌ Error loading categories: ${error.message}`, 'error');
                    this.showError('שגיאה בטעינת הקטגוריות');
                }
            }

            displayCategories(categories) {
                const contentArea = document.getElementById('contentArea');
                contentArea.innerHTML = '';

                if (!Array.isArray(categories)) {
                    this.log('❌ Categories is not an array:', categories, 'error');
                    return;
                }

                const grid = document.createElement('div');
                grid.className = 'grid';

                categories.forEach(category => {
                    if (category.category) {
                        const card = this.createCard(
                            category.category,
                            category.heCategory || '',
                            () => this.navigateToCategory(category)
                        );
                        grid.appendChild(card);
                    }
                });

                contentArea.appendChild(grid);
                this.updateBreadcrumb();
            }

            async navigateToCategory(category) {
                try {
                    this.log(`🔍 Navigating to category: ${category.category}`);
                    this.currentPath.push(category);

                    if (category.contents) {
                        this.displayContents(category.contents);
                    } else {
                        // טען תוכן הקטגוריה
                        const response = await fetch(`${this.baseUrl}/index/${encodeURIComponent(category.category)}`);
                        const data = await response.json();

                        this.displayContents(data.contents || []);
                    }

                    this.updateBreadcrumb();
                    this.updateBackButton();
                } catch (error) {
                    this.log(`❌ Error navigating to category: ${error.message}`, 'error');
                }
            }

            displayContents(contents) {
                const contentArea = document.getElementById('contentArea');
                contentArea.innerHTML = '';

                if (!Array.isArray(contents)) {
                    this.log('❌ Contents is not an array:', contents, 'error');
                    return;
                }

                const grid = document.createElement('div');
                grid.className = 'grid';

                contents.forEach(item => {
                    if (item.category) {
                        // זוהי תת-קטגוריה
                        const card = this.createCard(
                            item.category,
                            item.heCategory || '',
                            () => this.navigateToCategory(item)
                        );
                        grid.appendChild(card);
                    } else if (item.title) {
                        // זהו ספר
                        const card = this.createCard(
                            item.title,
                            item.heTitle || '',
                            () => this.selectBook(item)
                        );
                        card.classList.add('book-card');
                        grid.appendChild(card);
                    }
                });

                contentArea.appendChild(grid);
            }

            createCard(title, subtitle, onClick) {
                const card = document.createElement('div');
                card.className = 'card';
                card.onclick = onClick;

                const titleEl = document.createElement('div');
                titleEl.className = 'card-title';
                titleEl.textContent = subtitle;

                const subtitleEl = document.createElement('div');
                subtitleEl.className = 'card-subtitle';
                subtitleEl.textContent = title;

                card.appendChild(titleEl);
                card.appendChild(subtitleEl);

                return card;
            }

async selectBook(book) {
    try {
        this.log(`📖 Selected book: ${book.title}`);
        this.currentBook = book;
        
        // נקה cache פירושים עבור ספר חדש
        this.commentaryCache.clear();
        this.log('🧹 Cleared commentary cache');

        // טען מידע על הספר מ-API v2 raw index
        const v2Response = await fetch(`${this.baseUrl}/v2/raw/index/${encodeURIComponent(book.title)}`);
        this.bookData = await v2Response.json();
        

        // בדוק אם זהו ספר מורכב (עם sections) או פשוט
        if (this.bookData.schema && this.bookData.schema.nodes && this.bookData.schema.nodes.length > 0) {
            this.log(`📚 Complex book with ${this.bookData.schema.nodes.length} sections`);
            this.showSectionStep();
        } else {
            this.log('📖 Simple book structure');
            this.showChapterStep();
            this.populateChapters();
        }
    } catch (error) {
        this.log(`❌ Error selecting book: ${error.message}`, 'error');
        this.showError('שגיאה בטעינת הספר');
    }
}

            showSectionStep() {
                document.getElementById('categoriesStep').classList.add('hidden');
                document.getElementById('sectionStep').classList.remove('hidden');
                document.getElementById('selectedBookTitleSection').textContent = this.currentBook.heTitle || this.currentBook.title;
                this.populateSections();
            }

            populateSections() {
                const sectionSelect = document.getElementById('sectionSelect');
                sectionSelect.innerHTML = '<option value="">בחר חלק...</option>';


                if (this.bookData.schema && this.bookData.schema.nodes) {
                    this.bookData.schema.nodes.forEach((section, index) => {
                        const option = document.createElement('option');
                        option.value = section.key || section.title;
                        option.textContent = section.titles[1].text || section.title;
                        option.dataset.index = index;
                        sectionSelect.appendChild(option);
                    });
                    this.log(`📑 Added ${this.bookData.schema.nodes.length} sections`);
                }
            }

            async onSectionSelect() {
                const sectionSelect = document.getElementById('sectionSelect');
                const selectedOption = sectionSelect.options[sectionSelect.selectedIndex];

                if (!selectedOption.value) return;


                this.currentSection = {
                    key: selectedOption.value,
                    index: parseInt(selectedOption.dataset.index),
                    title: selectedOption.textContent,
                    data: this.bookData.schema.nodes[selectedOption.dataset.index],
                };

                this.log(`📑 Selected section: ${this.currentSection.title}`, this.currentSection);
                this.showChapterStep();
                this.populateChaptersForSection();
            }

            populateChaptersForSection() {
                const chapterSelect = document.getElementById('chapterSelect');
                chapterSelect.innerHTML = '<option value="">בחר פרק...</option>';

                const sectionData = this.currentSection.data;

                // חשב כמה פרקים יש בסקשן הזה
                if (sectionData.index_offsets_by_depth && sectionData.index_offsets_by_depth["2"]) {
                    const offsets = sectionData.index_offsets_by_depth["2"];
                    const numChapters = offsets.length;

                    this.log(`📖 Section has ${numChapters} chapters`);

                    for (let i = 1; i <= numChapters; i++) {
                        const option = document.createElement('option');
                        option.value = i;
                        option.textContent = `פרק ${i}`;
                        chapterSelect.appendChild(option);
                    }

                    // עדכן UI
                    document.getElementById('selectedSectionTitle').classList.remove('hidden');
                    console.log(this.currentSection, "current section");

                    document.getElementById('selectedSectionName').textContent = this.currentSection.title;
                } else {
                    this.log('❌ No chapter information found for section', 'error');
                }
            }

            showChapterStep() {
                document.getElementById('categoriesStep').classList.add('hidden');
                document.getElementById('sectionStep').classList.add('hidden');
                document.getElementById('chapterStep').classList.remove('hidden');
                document.getElementById('selectedBookTitle').textContent = this.currentBook.heTitle || this.currentBook.title;

                // הסתר או הצג את מידע הסקשן
                if (this.currentSection) {
                    document.getElementById('selectedSectionTitle').classList.remove('hidden');
                    document.getElementById('selectedSectionName').textContent = this.currentSection.title;
                    document.getElementById('backToSectionBtn').style.display = 'inline-block';
                } else {
                    document.getElementById('selectedSectionTitle').classList.add('hidden');
                    document.getElementById('backToSectionBtn').style.display = 'none';
                }
            }

           populateChapters() {
    const chapterSelect = document.getElementById('chapterSelect');
    chapterSelect.innerHTML = '<option value="">בחר פרק...</option>';

    // בדוק את המבנה של הספר לקבלת מספר הפרקים
    let chapterCount = 0;
    
    this.log('📊 Book structure:', this.bookData);
    
    // נסה למצוא את מספר הפרקים בדרכים שונות בהתאם למבנה הספר
    if (this.bookData.schema && this.bookData.schema.lengths && this.bookData.schema.lengths.length > 0) {
        // שימוש ב-schema.lengths לספרים חדשים
        chapterCount = this.bookData.schema.lengths[0];
        this.log(`📚 Using schema.lengths: ${chapterCount} chapters`);
    } else if (this.bookData.schema && this.bookData.schema.content_counts && this.bookData.schema.content_counts.length > 0) {
        // שימוש ב-schema.content_counts לחלק מהספרים
        chapterCount = this.bookData.schema.content_counts.length;
        this.log(`📚 Using schema.content_counts: ${chapterCount} chapters`);
    } else if (this.bookData.lengths && this.bookData.lengths.length > 0) {
        // שימוש ב-lengths לספרים ישנים
        chapterCount = this.bookData.lengths[0];
        this.log(`📚 Using book.lengths: ${chapterCount} chapters`);
    } else if (this.bookData.alt_structs && this.bookData.alt_structs.Parasha && this.bookData.alt_structs.Parasha.nodes) {
        // התמודדות עם ספרים שמאורגנים לפי פרשות
        chapterCount = this.estimateChaptersFromParashiot(this.bookData.alt_structs.Parasha.nodes);
        this.log(`📚 Estimated from Parashot: ${chapterCount} chapters`);
    } else {
        // אם אין לנו מידע מדויק, נשתמש במספר ברירת מחדל
        chapterCount = 50; // מספר גדול לחומש
        this.log(`📚 Using default chapter count: ${chapterCount}`);
    }
    
    // הוסף את האפשרויות לבחירת הפרק
    for (let i = 1; i <= chapterCount; i++) {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = `פרק ${i}`;
        chapterSelect.appendChild(option);
    }
    
    this.log(`📚 Added ${chapterCount} chapters to select menu`);
}
// פונקציית עזר להערכת מספר הפרקים מרשימת פרשיות
estimateChaptersFromParashiot(parashiot) {
    try {
        let maxChapter = 0;
        
        for (const parasha of parashiot) {
            if (parasha.wholeRef) {
                // נסה לחלץ את המספרים מהפניה
                const match = parasha.wholeRef.match(/(\d+):(\d+)-(\d+):(\d+)/);
                if (match && match[3]) {
                    const endChapter = parseInt(match[3]);
                    if (endChapter > maxChapter) {
                        maxChapter = endChapter;
                    }
                }
            }
        }
        
        return maxChapter || 50; // ברירת מחדל אם לא מצאנו
    } catch (error) {
        this.log(`❌ Error estimating chapters from parashiot: ${error.message}`, 'error');
        return 50; // ברירת מחדל
    }
}
async onChapterSelect() {
    const chapterNum = document.getElementById('chapterSelect').value;
    if (!chapterNum) return;

    try {
        this.log(`📄 Loading chapter ${chapterNum}`);
        this.currentChapter = chapterNum;

        // בנה את ההפניה בהתאם לסוג הספר
        let chapterRef;
        if (this.currentSection) {
            chapterRef = `${this.currentBook.title}, ${this.currentSection.key} ${chapterNum}`;
        } else {
            chapterRef = `${this.currentBook.title} ${chapterNum}`;
        }

        this.log(`🔗 Chapter reference: ${chapterRef}`);

        // שלוף את מידע הפרק כדי לקבל כותרות נכונות
        const chapterInfoResponse = await fetch(`${this.baseUrl}/texts/${encodeURIComponent(chapterRef)}`);
        const chapterInfo = await chapterInfoResponse.json();

        // שמור מידע נוסף על הפרק
        this.chapterInfo = {
            heTitle: chapterInfo.heTitle || '',
            heSectionRef: chapterInfo.heSectionRef || '',
            bookTitle: chapterInfo.book || this.currentBook.title,
            heBook: chapterInfo.heBook || '',
            // טפל במקרה שאין offset
            offset: chapterInfo.index_offsets_by_depth?.["2"]?.[0] || 0
        };
        

        // עבור ספרים פשוטים, אנחנו כבר קיבלנו את כל המידע בשלב זה
        const isSimpleBook = !this.currentSection;
        if (isSimpleBook && chapterInfo.he && Array.isArray(chapterInfo.he)) {
            this.chapterData = chapterInfo;
            this.log('📚 Direct use of chapter data for simple book');
        } else {
            // שלוף פיסקא אחר פיסקא במקום כל הפרק עבור ספרים מורכבים
            await this.loadParagraphByParagraph(chapterRef);
        }

        this.showParagraphStep();
        this.populateParagraphs();
    } catch (error) {
        this.log(`❌ Error loading chapter: ${error.message}`, 'error');
        this.showError('שגיאה בטעינת הפרק');
    }
}

           async loadParagraphByParagraph(chapterRef) {
    this.log(`📝 Loading paragraphs for: ${chapterRef}`);
    
    // בדוק אם זה ספר פשוט או מורכב
    const isSimpleBook = !this.currentSection;
    
    if (isSimpleBook) {
        // עבור ספר פשוט - טען את כל הפרק בבת אחת
        try {
            this.log(`📚 Loading entire chapter at once for simple book: ${chapterRef}`);
            const response = await fetch(`${this.baseUrl}/texts/${encodeURIComponent(chapterRef)}`);
            
            if (response.ok) {
                const chapterData = await response.json();
                
                if (chapterData.he && Array.isArray(chapterData.he)) {
                    this.chapterData = chapterData;
                    this.log(`✅ Successfully loaded ${chapterData.he.length} paragraphs at once`);
                    return;
                } else {
                    this.log(`⚠️ Unexpected format for chapter data`);
                }
            } else {
                this.log(`❌ Failed to load chapter: ${response.status}`);
            }
        } catch (error) {
            this.log(`❌ Error loading full chapter: ${error.message}`);
        }
    }
    const chapterNum = parseInt(this.currentChapter);
    let expectedParagraphs = this.getExpectedParagraphCount(chapterNum);
    
    if (expectedParagraphs) {
        this.log(`📊 Expected ${expectedParagraphs} paragraphs for chapter ${chapterNum}`);
        await this.loadExactParagraphCount(chapterRef, expectedParagraphs);
    } else {
        this.log('📊 No expected count, using discovery method');
        await this.loadParagraphsDiscovery(chapterRef);
    }
}
            getExpectedParagraphCount(chapterNum) {
                // נסה למצוא את מספר הפיסקאות הצפוי מהמידע שיש לנו
                let counts = null;

                if (this.currentSection && this.currentSection.data.content_counts) {
                    counts = this.currentSection.data.content_counts;
                } else if (this.bookData.schema && this.bookData.schema.content_counts) {
                    counts = this.bookData.schema.content_counts;
                } else if (this.bookData.schema && this.bookData.schema.lengths) {
                    counts = this.bookData.schema.lengths;
                } else if (this.bookData.lengths && this.bookData.lengths.length > 1) {
                    counts = this.bookData.lengths[1]; // עבור ספרים פשוטים
                }

                if (counts && Array.isArray(counts) && counts[chapterNum - 1]) {
                    return counts[chapterNum - 1];
                }

                return null;
            }

            async loadExactParagraphCount(chapterRef, expectedCount) {
                this.log(`📚 Loading ${expectedCount} paragraphs exactly`);

                this.chapterData = { he: [] };

                for (let paragraphNum = 1; paragraphNum <= expectedCount; paragraphNum++) {
                    const paragraphRef = `${chapterRef}:${paragraphNum}`;

                    try {
                        this.log(`📄 Loading paragraph ${paragraphNum}/${expectedCount}: ${paragraphRef}`);

                        const response = await fetch(`${this.baseUrl}/texts/${encodeURIComponent(paragraphRef)}`);

                        if (response.ok) {
                            const paragraphData = await response.json();

                            if (paragraphData.he) {
                                const paragraphText = Array.isArray(paragraphData.he) ?
                                    paragraphData.he[0] || paragraphData.he.join(' ') : paragraphData.he;

                                if (paragraphText && paragraphText.trim()) {
                                    this.chapterData.he.push(paragraphText);
                                    this.log(`✅ Loaded paragraph ${paragraphNum}: ${paragraphText.substring(0, 50)}...`);
                                } else {
                                    this.chapterData.he.push(''); // שמור מקום ריק
                                    this.log(`⚠️ Empty paragraph ${paragraphNum}`);
                                }
                            } else {
                                this.chapterData.he.push(''); // שמור מקום ריק
                                this.log(`⚠️ No Hebrew text for paragraph ${paragraphNum}`);
                            }
                        } else {
                            this.chapterData.he.push(''); // שמור מקום ריק
                            this.log(`❌ Failed to load paragraph ${paragraphNum}: ${response.status}`);
                        }

                        // השהיה קצרה בין בקשות
                        await new Promise(resolve => setTimeout(resolve, 100));

                    } catch (error) {
                        this.log(`❌ Error loading paragraph ${paragraphNum}: ${error.message}`);
                        this.chapterData.he.push(''); // שמור מקום ריק
                    }
                }

                // הסר פיסקאות ריקות מהסוף
                while (this.chapterData.he.length > 0 && !this.chapterData.he[this.chapterData.he.length - 1].trim()) {
                    this.chapterData.he.pop();
                }

                this.log(`📊 Loaded ${this.chapterData.he.length} paragraphs out of ${expectedCount} expected`);
            }

            async loadParagraphsDiscovery(chapterRef) {
                this.log(`🔍 Discovering paragraphs for: ${chapterRef}`);

                // נסה לטעון את כל הפרק קודם
                try {
                    const fullChapterResponse = await fetch(`${this.baseUrl}/texts/${encodeURIComponent(chapterRef)}`);

                    if (fullChapterResponse.ok) {
                        const fullChapterData = await fullChapterResponse.json();

                        if (fullChapterData.he && Array.isArray(fullChapterData.he)) {
                            this.chapterData = fullChapterData;
                            this.log(`✅ Loaded ${fullChapterData.he.length} paragraphs from full chapter`);
                            return;
                        }
                    }
                } catch (error) {
                    this.log(`❌ Error loading full chapter: ${error.message}`);
                }

                // אם זה לא עבד, נשתמש בשיטת הגילוי המקורית
                await this.discoverExistingParagraphs(chapterRef);
            }


            async discoverExistingParagraphs(chapterRef) {
                this.log(`🔍 Discovering existing paragraphs for: ${chapterRef}`);

                this.chapterData = { he: [] };
                const maxAttempts = 200;
                const maxFailures = 10; // עצור אחרי 10 כישלונות רצופים
                let consecutiveFailures = 0;

                for (let paragraphNum = 1; paragraphNum <= maxAttempts; paragraphNum++) {
                    const paragraphRef = `${chapterRef}:${paragraphNum}`;

                    try {
                        this.log(`🔍 Trying paragraph ${paragraphNum}`);

                        const response = await fetch(`${this.baseUrl}/texts/${encodeURIComponent(paragraphRef)}`);

                        if (response.ok) {
                            const paragraphData = await response.json();

                            if (paragraphData.he && paragraphData.he.length > 0) {
                                const paragraphText = Array.isArray(paragraphData.he) ?
                                    paragraphData.he[0] : paragraphData.he;

                                if (paragraphText && paragraphText.trim()) {
                                    this.chapterData.he.push(paragraphText);
                                    this.log(`✅ Found paragraph ${paragraphNum}`);
                                    consecutiveFailures = 0;
                                } else {
                                    consecutiveFailures++;
                                }
                            } else {
                                consecutiveFailures++;
                            }
                        } else if (response.status === 404) {
                            consecutiveFailures++;
                            this.log(`⏭️ Paragraph ${paragraphNum} not found (404)`);
                        } else {
                            consecutiveFailures++;
                            this.log(`❌ Error ${response.status} for paragraph ${paragraphNum}`);
                        }

                        // עצור אם יש יותר מדי כישלונות רצופים
                        if (consecutiveFailures >= maxFailures) {
                            this.log(`🛑 Stopping after ${maxFailures} consecutive failures`);
                            break;
                        }

                        // השהיה קצרה בין בקשות
                        await new Promise(resolve => setTimeout(resolve, 50));

                    } catch (error) {
                        this.log(`❌ Error fetching paragraph ${paragraphNum}: ${error.message}`);
                        consecutiveFailures++;

                        if (consecutiveFailures >= maxFailures) {
                            break;
                        }
                    }
                }

                this.log(`📊 Discovery complete: ${this.chapterData.he.length} paragraphs found`);

                if (this.chapterData.he.length === 0) {
                    this.log('⚠️ No paragraphs found, trying final fallback');
                    await this.loadChapterFallback(chapterRef);
                }
            }

            async loadChapterFallback(chapterRef) {
                // שלוף את כל הפרק
                try {
                    const response = await fetch(`${this.baseUrl}/texts/${encodeURIComponent(chapterRef)}`);
                    const data = await response.json();


                    if (data.he && Array.isArray(data.he)) {
                        this.chapterData = data;
                        this.log(`📚 Fallback: loaded ${data.he.length} paragraphs from full chapter`);
                    } else if (data.he) {
                        this.chapterData = { he: [data.he] };
                        this.log('📚 Fallback: loaded single paragraph');
                    }
                } catch (error) {
                    this.log(`❌ Fallback also failed: ${error.message}`, 'error');
                }
            }

            showParagraphStep() {
                document.getElementById('chapterStep').classList.add('hidden');
                document.getElementById('paragraphStep').classList.remove('hidden');

                let title = `${this.currentBook.heTitle || this.currentBook.title}`;
                if (this.currentSection) {
                    title += `, ${this.currentSection.title}`;
                }
                title += ` פרק ${this.currentChapter}`;

                document.getElementById('selectedChapterTitle').textContent = title;
            }

            async onParagraphRangeChange() {
                const start = document.getElementById('startParagraph').value;
                const end = document.getElementById('endParagraph').value;

                if (start && end) {
                    this.log(`📝 Paragraph range selected: ${start} to ${end}`);

                    await this.loadVersions();
                    await this.loadCommentaries();

                    document.getElementById('generateBtn').disabled = false;
                } else {
                    document.getElementById('generateBtn').disabled = true;
                }
            }

            async loadVersions() {
                try {
                    this.log('📚 Loading versions...');
                    const response = await fetch(`${this.baseUrl}/texts/versions/${encodeURIComponent(this.currentBook.title)}`);
                    const versions = await response.json();


                    const container = document.getElementById('versionsContainer');
                    container.innerHTML = '';

                    if (Array.isArray(versions)) {
                        versions.forEach(version => {
                            if (version.languageFamilyName !== 'hebrew' || !version.isPrimary) {
                                const label = document.createElement('label');
                                const checkbox = document.createElement('input');
                                checkbox.type = 'checkbox';
                                checkbox.value = version.versionTitle;
                                checkbox.dataset.language = version.languageFamilyName;
                                checkbox.dataset.title = version.versionTitle;

                                label.appendChild(checkbox);
                                label.appendChild(document.createTextNode(`${version.versionTitle} (${version.languageFamilyName})`));
                                container.appendChild(label);
                            }
                        });
                    }
                } catch (error) {
                    this.log(`❌ Error loading versions: ${error.message}`, 'error');
                }
            }

     populateParagraphs() {
    const startSelect = document.getElementById('startParagraph');
    const endSelect = document.getElementById('endParagraph');
    
    startSelect.innerHTML = '<option value="">בחר התחלה...</option>';
    endSelect.innerHTML = '<option value="">בחר סוף...</option>';

    if (this.chapterData.he && Array.isArray(this.chapterData.he)) {
        const numParagraphs = this.chapterData.he.length;
        this.log(`📝 Chapter has ${numParagraphs} paragraphs`);

        // קבע את התווית המתאימה בהתבסס על סוג הספר
        const paraLabel = this.currentSection ? 'פיסקא' : 'פסוק';
        
        // קבע את ההיסט לפסוקים
        let offset = 0;
        
        // אם יש לנו offset מה-API, נשתמש בו
        if (this.chapterInfo && this.chapterInfo.offset !== undefined) {
            offset = this.chapterInfo.offset;
            this.log(`📊 Using API offset: ${offset}`);
        } else {
            this.log(`📊 No offset available, using 0`);
        }

        for (let i = 1; i <= numParagraphs; i++) {
            const displayNumber = i + offset;
            
            const startOption = document.createElement('option');
            startOption.value = displayNumber;
            startOption.textContent = `${paraLabel} ${displayNumber}`;
            startSelect.appendChild(startOption);

            const endOption = document.createElement('option');
            endOption.value = displayNumber;
            endOption.textContent = `${paraLabel} ${displayNumber}`;
            endSelect.appendChild(endOption);
        }
        
        // ודא שה-event listeners עובדים
        this.log('🔧 Re-ensuring event listeners for paragraph selects');
        startSelect.removeEventListener('change', this.onParagraphRangeChange.bind(this));
        endSelect.removeEventListener('change', this.onParagraphRangeChange.bind(this));
        startSelect.addEventListener('change', this.onParagraphRangeChange.bind(this));
        endSelect.addEventListener('change', this.onParagraphRangeChange.bind(this));
        
    } else {
        this.log('❌ No paragraph data found in chapter', 'error');
        
        // fallback - צור כמה פיסקאות כברירת מחדל
        for (let i = 1; i <= 10; i++) {
            const startOption = document.createElement('option');
            startOption.value = i;
            startOption.textContent = `פסוק ${i}`;
            startSelect.appendChild(startOption);

            const endOption = document.createElement('option');
            endOption.value = i;
            endOption.textContent = `פסוק ${i}`;
            endSelect.appendChild(endOption);
        }
    }
}
            async generateDocument() {
                try {
                    this.log('📄 Generating document...');
                    document.getElementById('generateBtn').disabled = true;
                    document.getElementById('generateLoading').classList.remove('hidden');

                    const start = parseInt(document.getElementById('startParagraph').value);
                    const end = parseInt(document.getElementById('endParagraph').value);

                    // איסוף הגירסאות הנבחרות
                    const selectedVersions = Array.from(document.querySelectorAll('#versionsContainer input[type="checkbox"]:checked'))
                        .map(cb => {
                            const title = cb.dataset.title;
                            const language = cb.dataset.language;

                            this.log(`📝 Selected version: ${title} (${language})`);

                            return {
                                title: title,
                                language: language
                            };
                        })
                        .filter(v => v.title && v.language); // סנן גירסאות לא תקינות

                    // איסוף המפרשים הנבחרים
                    const selectedCommentaries = Array.from(document.querySelectorAll('#commentariesContainer input:checked'))
                        .map(cb => cb.value);

                    this.log(`📊 Selected range: ${start} to ${end}`);
                    this.log(`📚 Selected versions:`, selectedVersions);
                    this.log(`📝 Selected commentaries: ${selectedCommentaries.join(', ') || 'none'}`);



                    // שלוף את כל הפיסקאות בטווח
                    const documentData = await this.fetchDocumentData(start, end, selectedVersions, selectedCommentaries);

                    // יצור קובץ Word
                    this.createWordDocument(documentData);

                    this.log('✅ Document generated successfully!', 'success');
                    this.showSuccess('המסמך נוצר בהצלחה!');

                } catch (error) {
                    this.log(`❌ Error generating document: ${error.message}`, 'error');
                    this.showError('שגיאה ביצירת המסמך');
                } finally {
                    document.getElementById('generateBtn').disabled = false;
                    document.getElementById('generateLoading').classList.add('hidden');
                }
            }

      async fetchDocumentData(startParagraph, endParagraph, selectedVersions, selectedCommentaries) {
    const documentData = [];

    this.log(`📚 Processing paragraphs ${startParagraph} to ${endParagraph}`);

    for (let index = startParagraph; index <= endParagraph; index++) {
        this.log(`📄 Processing paragraph ${index}`);

        // חישוב אינדקס המערך בהתחשב בהיסט
        const offset = this.chapterInfo.offset || 0;
        const arrayIndex = index - offset - 1;
        
        this.log(`📊 Array index for paragraph ${index}: ${arrayIndex} (offset: ${offset})`);
        
        // בדוק שהאינדקס תקין
        if (arrayIndex < 0 || arrayIndex >= this.chapterData.he.length) {
            this.log(`⚠️ Invalid array index ${arrayIndex} for paragraph ${index}`);
            continue;
        }

        const hebrewText = this.chapterData.he[arrayIndex];
        
        // בנה הפניה לפיסקא בפורמט הנכון
        let paragraphRef;
        if (this.currentSection) {
            paragraphRef = `${this.currentBook.title}, ${this.currentSection.key} ${this.currentChapter}:${index}`;
        } else {
            paragraphRef = `${this.currentBook.title} ${this.currentChapter}:${index}`;
        }
        
        this.log(`🔗 Paragraph reference: ${paragraphRef}`);
        
        try {
            // נקה את הטקסט מ-HTML tags
            const cleanText = hebrewText.replace(/<[^>]*>/g, '').trim();

            if (!cleanText) {
                this.log(`⚠️ Empty text for paragraph ${index}`);
                continue;
            }

            // שלוף מפרשים לפיסקא זו
            const commentaries = await this.fetchCommentariesForParagraph(paragraphRef, selectedCommentaries);

            // שלוף גירסאות נוספות - באמצעות גישה יעילה יותר
            const additionalVersions = await this.fetchAdditionalVersionsEfficient(paragraphRef, selectedVersions, arrayIndex);

            documentData.push({
                paragraphNum: index,
                ref: paragraphRef,
                hebrewText: cleanText,
                additionalVersions,
                commentaries
            });

            this.log(`✅ Added paragraph ${index} with ${commentaries.length} commentaries`);

        } catch (error) {
            this.log(`❌ Error processing paragraph ${index}: ${error.message}`, 'error');
        }

        // השהיה קצרה בין בקשות
        await new Promise(resolve => setTimeout(resolve, 100));
    }

    this.log(`🎉 Document data ready: ${documentData.length} paragraphs`);
    return documentData;
}
async fetchAdditionalVersionsEfficient(ref, selectedVersions, arrayIndex) {
    if (!selectedVersions || selectedVersions.length === 0) {
        return [];
    }

    this.log(`📚 Fetching additional versions for: ${ref}`);
    const versions = [];

    for (const version of selectedVersions) {
        try {
            // ודא שיש לנו title ו-language תקינים
            if (!version.title || !version.language) {
                this.log(`⚠️ Skipping invalid version:`, version);
                continue;
            }
            
            this.log(`🔍 Fetching version: ${version.title} (${version.language})`);
            
            // יצירת מפתח מטמון לגרסה זו
            const cacheKey = `${this.currentChapter}_${version.title}`;
            
            // בדיקה אם יש לנו כבר את כל הפרק במטמון
            let versionChapterData = this.commentaryCache.get(cacheKey);
            
            if (!versionChapterData) {
                // אם אין במטמון, נטען את כל הפרק
                const chapterRef = ref.split(':')[0]; // לקבל רק את ההפניה לפרק ללא מספר פסוק
                const encodedRef = encodeURIComponent(chapterRef);
                const versionParam = encodeURIComponent(`${version.language}|${version.title}`);
                const url = `${this.baseUrl}/v3/texts/${encodedRef}?version=${versionParam}`;
                
                this.log(`🌐 Version URL for whole chapter: ${url}`);
                
                const response = await fetch(url);
                
                if (response.ok) {
                    versionChapterData = await response.json();
                    this.log(`📊 Version chapter data for ${version.title}:`, versionChapterData);
                    
                    // שמור במטמון לשימוש עתידי
                    this.commentaryCache.set(cacheKey, versionChapterData);
                } else {
                    this.log(`❌ Failed to fetch version ${version.title}: ${response.status}`);
                    continue;
                }
            } else {
                this.log(`📋 Using cached chapter data for version: ${version.title}`);
            }
            
            // חלץ את הטקסט הספציפי לפסוק/פיסקא מנתוני הפרק בהתאם לשפה
            let versionText = '';
                versionText = versionChapterData.versions[0].text[arrayIndex];
                        this.log(`📄 Found ${version.text} text for ${version.title} `);
      
            if (!versionText) {
                this.log(`⚠️ No text found for version ${version.title} at index ${arrayIndex}`);
                continue;
            }
            
            if (versionText && versionText.trim()) {
                // נקה מ-HTML tags
                versionText = versionText.replace(/<[^>]*>/g, '').trim();
                
                versions.push({
                    title: version.title,
                    heTitle: versionChapterData.versions[0].versionTitleInHebrew || '',
                    heRef: version.heRef || '',
                    language: version.language,
                    text: versionText
                });
                
                this.log(`✅ Added version: ${version.title} (${versionText.length} chars)`);
            } else {
                this.log(`⚠️ No text found for version ${version.title} at index ${arrayIndex}`);
                
                // אם לא הצלחנו למצוא טקסט ספציפי, ננסה את השיטה הישנה
                await this.fetchVersionFallback(ref, version, versions);
            }
            
        } catch (error) {
            this.log(`❌ Error fetching version ${version.title}: ${error.message}`, 'error');
            
            // נסה fallback במקרה של שגיאה
            await this.fetchVersionFallback(ref, version, versions);
        }
    }

    this.log(`📚 Fetched ${versions.length} additional versions`);
    return versions;
}
            async fetchCommentariesForParagraph(ref, selectedCommentaries) {
                if (selectedCommentaries.length === 0) return [];

                try {
                    this.log(`📝 Fetching commentaries for: ${ref}`);

                    const response = await fetch(`${this.baseUrl}/links/${encodeURIComponent(ref)}`);
                    const links = await response.json();


                    const commentaries = [];

                    if (Array.isArray(links)) {
                        for (const link of links) {
                            if (link.category === 'Commentary' && link.collectiveTitle) {
                                const commentaryTitle = link.collectiveTitle.he || link.collectiveTitle.en;

                                if (selectedCommentaries.includes(commentaryTitle)) {
                                    this.log(`🔍 Processing commentary: ${commentaryTitle} -> ${link.sourceRef}`);

                                    // שלוף את טקסט הפירוש באופן חכם יותר
                                    const commentaryText = await this.fetchCommentaryTextSmart(link.sourceRef, ref);
                                    if (commentaryText) {
                                        commentaries.push({
                                            title: commentaryTitle,
                                            text: commentaryText,
                                            ref: link.sourceRef
                                        });
                                        this.log(`✅ Added commentary: ${commentaryTitle} (${commentaryText.length} chars)`);
                                    }
                                }
                            }
                        }
                    }

                    return commentaries;
                } catch (error) {
                    this.log(`❌ Error fetching commentaries for ${ref}: ${error.message}`, 'error');
                    return [];
                }
            }

            async fetchCommentaryTextSmart(commentaryRef, originalRef) {
                try {
                    this.log(`📖 Fetching commentary smartly: ${commentaryRef}`);

                    // פרק את ההפניה לזיהוי הפיסקא הספציפית
                    const { baseRef, paragraphNum } = this.parseCommentaryRef(commentaryRef, originalRef);

                    this.log(`🔍 Parsed: baseRef=${baseRef}, paragraphNum=${paragraphNum}`);

                    // שלוף את כל הפירוש (הדף/פרק) בבת אחת
                    const response = await fetch(`${this.baseUrl}/texts/${encodeURIComponent(baseRef)}`);
                    const data = await response.json();

                    this.log(`📊 Commentary data for ${baseRef}:`, data);

                    // חלץ את הטקסט הספציפי מהמערך
                    let text = '';

                    if (data.he && Array.isArray(data.he) && paragraphNum !== null) {
                        // יש מערך ואנחנו יודעים איזה פיסקא
                        const paragraphIndex = paragraphNum - 1;
                        if (paragraphIndex >= 0 && paragraphIndex < data.he.length) {
                            text = data.he[paragraphIndex];
                            this.log(`✅ Found specific paragraph ${paragraphNum}: ${text.substring(0, 100)}...`);
                        } else {
                            this.log(`❌ Paragraph ${paragraphNum} not found in array of ${data.he.length} items`);
                        }
                    } else if (data.he) {
                        // אם אין מערך או לא יודעים את המספר, קח את הכל
                        if (Array.isArray(data.he)) {
                            text = data.he.join(' ');
                        } else {
                            text = data.he;
                        }
                        this.log(`📄 Using full commentary text (${text.length} chars)`);
                    } else if (data.text) {
                        if (Array.isArray(data.text)) {
                            text = data.text.join(' ');
                        } else {
                            text = data.text;
                        }
                    }

                    // נקה את הטקסט מ-HTML tags
                    if (text) {
                        text = text.replace(/<[^>]*>/g, '').trim();
                    }

                    this.log(`📝 Final commentary text (${text.length} chars): ${text.substring(0, 100)}...`);
                    return text;

                } catch (error) {
                    this.log(`❌ Error fetching commentary text: ${error.message}`, 'error');
                    return '';
                }
            }

            parseCommentaryRef(commentaryRef, originalRef) {
                // נסה לפרק את ההפניה למציאת הפיסקא הרלוונטית
                try {
                    // דוגמא: "Mikdash Melekh on Zohar 1:1a:1" -> baseRef="Mikdash Melekh on Zohar 1:1a", paragraphNum=1
                    const parts = commentaryRef.split(':');

                    if (parts.length >= 3) {
                        // יש מספר פיסקא באחרון
                        const paragraphNum = parseInt(parts[parts.length - 1]);
                        const baseRef = parts.slice(0, -1).join(':');

                        if (!isNaN(paragraphNum)) {
                            return { baseRef, paragraphNum };
                        }
                    }

                    // אם לא הצלחנו לפרק, נחזיר את כל ההפניה כ-baseRef
                    return { baseRef: commentaryRef, paragraphNum: null };

                } catch (error) {
                    this.log(`❌ Error parsing commentary ref: ${error.message}`);
                    return { baseRef: commentaryRef, paragraphNum: null };
                }
            }

            async fetchAdditionalVersions(ref, selectedVersions) {
                if (!selectedVersions || selectedVersions.length === 0) {
                    return [];
                }

                this.log(`📚 Fetching additional versions for: ${ref}`);
                const versions = [];

                for (const version of selectedVersions) {
                    try {
                        // ודא שיש לנו title ו-language תקינים
                        if (!version.title || !version.language) {
                            this.log(`⚠️ Skipping invalid version:`, version);
                            continue;
                        }

                        this.log(`🔍 Fetching version: ${version.title} (${version.language})`);

                        // השתמש ב-API v3 עם פרמטר version בפורמט הנכון: language|versionTitle
                        const encodedRef = encodeURIComponent(ref);
                        const versionParam = encodeURIComponent(`${version.language}|${version.title}`);
                        const url = `${this.baseUrl}/v3/texts/${encodedRef}?version=${versionParam}`;

                        this.log(`🌐 Version URL: ${url}`);

                        const response = await fetch(url);

                        if (response.ok) {
                            const versionData = await response.json();

                            let versionText = '';
                            console.log(versionData, "versionData");
                            
                            // נסה לחלץ את הטקסט מהגירסה
                            if (versionData.versions && versionData.versions.length > 0) {
                                // API v3 מחזיר versions array
                                const versionInfo = versionData.versions.find(v => v.versionTitle === version.title) ||
                                    versionData.versions.find(v => v.language === version.language) ||
                                    versionData.versions[0];

                                if (versionInfo && versionInfo.text) {
                                    if (Array.isArray(versionInfo.text)) {
                                        versionText = versionInfo.text[0] || '';
                                    } else {
                                        versionText = versionInfo.text;
                                    }
                                }
                            } else if (versionData.text) {
                                // fallback לפורמט ישן
                                if (Array.isArray(versionData.text)) {
                                    versionText = versionData.text[0] || '';
                                } else {
                                    versionText = versionData.text;
                                }
                            } else if (versionData.he) {
                                if (Array.isArray(versionData.he)) {
                                    versionText = versionData.he[0] || '';
                                } else {
                                    versionText = versionData.he;
                                }
                            } else if (versionData.en) {
                                if (Array.isArray(versionData.en)) {
                                    versionText = versionData.en[0] || '';
                                } else {
                                    versionText = versionData.en;
                                }
                            }

                            if (versionText && versionText.trim()) {
                                // נקה מ-HTML tags
                                versionText = versionText.replace(/<[^>]*>/g, '').trim();

                                versions.push({
                                    title: version.title,
                                    heTitle: version.HeTile,
                                    heRef: version.heRef,
                                    language: version.language,
                                    text: versionText
                                });

                                this.log(`✅ Added version: ${version.title} (${versionText.length} chars)`);
                            } else {
                                this.log(`⚠️ No text found for version2: ${version.title}`);
                            }
                        } else {
                            this.log(`❌ Failed to fetch version ${version.title}: ${response.status}`);

                            // נסה fallback עם API רגיל
                            await this.fetchVersionFallback(ref, version, versions);
                        }

                        // השהיה קצרה בין בקשות
                        await new Promise(resolve => setTimeout(resolve, 100));

                    } catch (error) {
                        this.log(`❌ Error fetching version ${version.title}: ${error.message}`, 'error');

                        // נסה fallback במקרה של שגיאה
                        await this.fetchVersionFallback(ref, version, versions);
                    }
                }

                this.log(`📚 Fetched ${versions.length} additional versions`);
                return versions;
            }

            async fetchVersionFallback(ref, version, versions) {
                try {
                    this.log(`🔄 Trying fallback for version: ${version.title}`);

                    // נסה עם API רגיל עם פרמטר version
                    const versionParam = encodeURIComponent(`${version.language}|${version.title}`);
                    const url = `${this.baseUrl}/v3/texts/${encodeURIComponent(ref)}?version=${versionParam}`;

                    this.log(`🌐 Fallback URL: ${url}`);

                    const response = await fetch(url);

                    if (response.ok) {
                        const versionData = await response.json();

                        let versionText = '';

                        if (versionData.text && Array.isArray(versionData.text) && versionData.text.length > 0) {
                            versionText = versionData.text[0];
                        } else if (versionData.text) {
                            versionText = versionData.text;
                        } else if (versionData.he && Array.isArray(versionData.he) && versionData.he.length > 0) {
                            versionText = versionData.he[0];
                        } else if (versionData.he) {
                            versionText = versionData.he;
                        } else if (versionData.en && Array.isArray(versionData.en) && versionData.en.length > 0) {
                            versionText = versionData.en[0];
                        } else if (versionData.en) {
                            versionText = versionData.en;
                        }

                        if (versionText && versionText.trim()) {
                            versionText = versionText.replace(/<[^>]*>/g, '').trim();

                            // בדוק אם עוד לא הוספנו את הגירסה הזו
                            const existingVersion = versions.find(v => v.title === version.title);
                            if (!existingVersion) {
                                versions.push({
                                    title: version.title,
                                    language: version.language,
                                    text: versionText
                                });

                                this.log(`✅ Fallback success: ${version.title} (${versionText.length} chars)`);
                            }
                        } else {
                            this.log(`⚠️ Fallback: No text found for ${version.title}`);
                        }
                    } else {
                        this.log(`❌ Fallback also failed: ${response.status}`);
                    }

                } catch (error) {
                    this.log(`❌ Fallback error: ${error.message}`, 'error');
                }
            }

            createWordDocument(documentData) {
                let html = `
                <!DOCTYPE html>
                <html dir="rtl" lang="he">
                <head>
                    <meta charset="UTF-8">
                    <style>
                        body { 
                            font-family: 'David', 'Times New Roman', serif; 
                            direction: rtl; 
                            text-align: right;
                            line-height: 1.8;
                            margin: 0.8cm;
                        }
                        .main-title { 
                            font-size: 24px; 
                            font-weight: bold; 
                            text-align: center; 
                            margin-bottom: 30px;
                            border-bottom: 2px solid #333;
                            padding-bottom: 10px;
                        }
                        .paragraph-container { 
                            margin-bottom: 30px; 
                            padding: 15px;
                            border: 1px solid #ddd;
                            border-radius: 5px;
                        }
                        .paragraph-header { 
                            font-size: 14px; 
                            font-weight: bold; 
                            color: #666;
                            margin-bottom: 10px;
                            background-color: #f0f0f0;
                            padding: 5px 10px;
                            border-radius: 3px;
                        }
                        .paragraph-text { 
                            font-size: 16px; 
                            font-weight: bold; 
                            margin-bottom: 15px;
                            line-height: 1.6;
                        }
                        .additional-versions-section {
                            margin-top: 15px;
                            padding-top: 10px;
                            border-top: 1px solid #e0e0e0;
                        }
                        .additional-version {
                            margin: 10px 0;
                            padding: 10px;
                            background-color: #f0f8ff;
                            border-right: 3px solid #4682b4;
                            border-radius: 3px;
                        }
                        .version-title {
                            font-weight: bold;
                            color: #4682b4;
                            margin-bottom: 5px;
                            font-size: 14px;
                        }
                        .version-text {
                            font-size: 15px;
                            color: #2c3e50;
                            line-height: 1.5;
                        }
                        .commentary-section {
                            margin-top: 15px;
                            padding-top: 10px;
                            border-top: 1px dashed #ccc;
                        }
                        .commentary-title { 
                            font-size: 14px; 
                            font-weight: bold; 
                            color: #8e44ad;
                            margin-bottom: 5px;
                        }
                        .commentary-text { 
                            font-size: 13px; 
                            color: #555;
                            margin-bottom: 10px;
                            padding: 8px;
                            background-color: #fafafa;
                            border-right: 3px solid #8e44ad;
                        }
                    </style>
                </head>
                <body>
                `;

                // כותרת ראשית
                let title = this.chapterInfo.heSectionRef || this.chapterInfo.heTitle;

                html += `<h1 class="main-title">${title}</h1>`;

                // הוספת כל הפיסקאות
                documentData.forEach(paragraph => {
                    html += `
                    <div class="paragraph-container">
                        <div class="paragraph-header">${paragraph.heTitle || paragraph.ref}</div>
                        <div class="paragraph-text">${paragraph.hebrewText}</div>
                    `;

                    // הוספת גירסאות נוספות
                    if (paragraph.additionalVersions && paragraph.additionalVersions.length > 0) {
                        html += `<div class="additional-versions-section">`;
                        paragraph.additionalVersions.forEach(version => {
                            html += `
                            <div class="additional-version">
                                <div class="version-title">${version.title} (${version.language})</div>
                                <div class="version-text">${version.text}</div>
                            </div>
                            `;
                        });
                        html += `</div>`;
                    }

                    // הוספת פירושים
                    if (paragraph.commentaries && paragraph.commentaries.length > 0) {
                        html += `<div class="commentary-section">`;
                        paragraph.commentaries.forEach(commentary => {
                            html += `
                            <div class="commentary-title">${commentary.title}</div>
                            <div class="commentary-text">${commentary.text}</div>
                            `;
                        });
                        html += `</div>`;
                    }

                    html += `</div>`;
                });

                html += `</body></html>`;

                // הורדת הקובץ
                const blob = new Blob([html], { type: 'application/msword' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${title.replace(/[^\u0590-\u05FF\w\s-]/g, '')}.doc`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            async loadCommentaries() {
                try {
                    this.log('📝 Loading commentaries...');
                    const start = document.getElementById('startParagraph').value;

                    if (!start) {
                        document.getElementById('commentariesContainer').innerHTML = '<div>בחר פיסקאות תחילה</div>';
                        return;
                    }

                    // בנה הפניה לפיסקא ראשונה כדוגמה
                    let sampleRef;
                    if (this.currentSection) {
                        sampleRef = `${this.currentBook.title}, ${this.currentSection.key} ${this.currentChapter}:${start}`;
                    } else {
                        sampleRef = `${this.currentBook.title} ${this.currentChapter}:${start}`;
                    }

                    this.log(`🔗 Sample commentary reference: ${sampleRef}`);

                    // נסה מספר דרכים למצוא מפרשים
                    const commentaries = await this.discoverCommentaries(sampleRef);

                    const container = document.getElementById('commentariesContainer');
                    container.innerHTML = '';

                    if (commentaries.size > 0) {
                        commentaries.forEach(title => {
                            const label = document.createElement('label');
                            const checkbox = document.createElement('input');
                            checkbox.type = 'checkbox';
                            checkbox.value = title;

                            label.appendChild(checkbox);
                            label.appendChild(document.createTextNode(title));
                            container.appendChild(label);
                        });

                        this.log(`✅ Found ${commentaries.size} commentaries`);
                    } else {
                        container.innerHTML = '<div>לא נמצאו מפרשים זמינים</div>';
                        this.log('❌ No commentaries found');
                    }
                } catch (error) {
                    this.log(`❌ Error loading commentaries: ${error.message}`, 'error');
                    document.getElementById('commentariesContainer').innerHTML = '<div>שגיאה בטעינת מפרשים</div>';
                }
            }

            async discoverCommentaries(ref) {
                const commentaries = new Set();

                // שיטה 1: שלוף קישורים ישירים
                try {
                    const response = await fetch(`${this.baseUrl}/links/${encodeURIComponent(ref)}`);

                    if (response.ok) {
                        const links = await response.json();

                        if (Array.isArray(links)) {
                            links.forEach(link => {
                                if (link.category === 'Commentary' && link.collectiveTitle) {
                                    const title = link.collectiveTitle.he || link.collectiveTitle.en;
                                    if (title) {
                                        commentaries.add(title);
                                        this.log(`📝 Found commentary: ${title}`);
                                    }
                                }
                            });
                        }
                    }
                } catch (error) {
                    this.log(`❌ Error fetching links: ${error.message}`);
                }

                if (commentaries.size === 0) {
                    this.log('🔍 No links found, trying known commentaries');
                }

                return commentaries;
            }

            updateBreadcrumb() {
                const breadcrumb = document.getElementById('breadcrumb');
                let path = '📍 דף הבית';

                this.currentPath.forEach(item => {
                    if (item.category) {
                        path += ` > ${item.heCategory || item.category}`;
                    } else if (item.title) {
                        path += ` > ${item.heTitle || item.title}`;
                    }
                });

                breadcrumb.textContent = path;
            }

            updateBackButton() {
                document.getElementById('backBtn').disabled = this.currentPath.length === 0;
            }

            // פונקציות עזר
            log(message, data = null, type = 'info') {
                const debugPanel = document.getElementById('debugPanel');
                const timestamp = new Date().toLocaleTimeString();

                let logEntry = `[${timestamp}] ${message}`;
                if (data) {
                    logEntry += '\n' + JSON.stringify(data, null, 2);
                }

                const logDiv = document.createElement('div');
                logDiv.style.color = type === 'error' ? '#ff6b6b' : type === 'success' ? '#51cf66' : '#74c0fc';
                logDiv.style.marginBottom = '5px';
                logDiv.textContent = logEntry;

                debugPanel.appendChild(logDiv);
                debugPanel.scrollTop = debugPanel.scrollHeight;

                console.log(message, data);
            }

            clearDebug() {
                document.getElementById('debugPanel').innerHTML = '<div>📱 Debug cleared</div>';
            }

            showError(message) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error';
                errorDiv.textContent = message;
                document.body.appendChild(errorDiv);

                setTimeout(() => {
                    if (errorDiv.parentNode) {
                        errorDiv.parentNode.removeChild(errorDiv);
                    }
                }, 5000);
            }

            showSuccess(message) {
                const successDiv = document.createElement('div');
                successDiv.className = 'success';
                successDiv.textContent = message;
                document.body.appendChild(successDiv);

                setTimeout(() => {
                    if (successDiv.parentNode) {
                        successDiv.parentNode.removeChild(successDiv);
                    }
                }, 5000);
            }
        }

        // התחלת האפליקציה
        document.addEventListener('DOMContentLoaded', () => {
            new SefariaNavigator();
        });
    </script>
</body>

</html>