<!DOCTYPE html>
<html dir="rtl" lang="he">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ניווט ספריא </title>
    <link rel="stylesheet" href="styles.css">
       

</head>

<body>
    <div class="container">
        <div class="header">
            <h1>🏛️ ניווט ספריא </h1>
            <p>נווט בספרי הקודש עם קישורים ופירושים </p>
        </div>

        <!-- שלב 1: ניווט לקטגוריות -->
        <div id="categoriesStep" class="step">
            <div class="breadcrumb" id="breadcrumb">📍 דף הבית</div>

            <div class="nav-buttons">
                <button class="btn" id="backBtn" disabled>🔙 חזור</button>
                <button class="btn" id="homeBtn">🏠 דף הבית</button>
            </div>

            <div id="contentArea">
                <div class="loading">טוען קטגוריות</div>
            </div>
        </div>

        <!-- שלב 2: בחירת section -->
        <div id="sectionStep" class="step hidden">
            <div class="breadcrumb" id="sectionBreadcrumb">📍 בחירת חלק</div>

            <div class="nav-buttons">
                <button class="btn" id="backToBookFromSectionBtn">🔙 חזור לספר</button>
                <button class="btn" id="homeFromSectionBtn">🏠 דף הבית</button>
            </div>

            <div class="section">
                <h3>📖 ספר נבחר: <span id="selectedBookTitleSection"></span></h3>
                <h3>📑 בחר חלק:</h3>
                <select id="sectionSelect">
                    <option value="">בחר חלק...</option>
                </select>
            </div>
        </div>

        <!-- שלב 3: בחירת פרק -->
        <div id="chapterStep" class="step hidden">
            <div class="breadcrumb" id="chapterBreadcrumb">📍 בחירת פרק</div>

            <div class="nav-buttons">
                <button class="btn" id="backToSectionBtn">🔙 חזור לחלק</button>
                <button class="btn" id="backToBookBtn">🔙 חזור לספר</button>
                <button class="btn" id="homeFromChapterBtn">🏠 דף הבית</button>
            </div>

            <div class="section">
                <h3>📖 נבחר: <span id="selectedBookTitle"></span></h3>
                <h3 id="selectedSectionTitle" class="hidden">📑 חלק: <span id="selectedSectionName"></span></h3>
                <h3>🔢 בחר פרק:</h3>
                <select id="chapterSelect">
                    <option value="">בחר פרק...</option>
                </select>
            </div>
        </div>

        <!-- שלב 4: בחירת פיסקאות וגירסאות -->
        <div id="paragraphStep" class="step hidden">
            <div class="breadcrumb" id="paragraphBreadcrumb">📍 בחירת פיסקאות ואפשרויות</div>

            <div class="nav-buttons">
                <button class="btn" id="backToChapterBtn">🔙 חזור לפרק</button>
                <button class="btn" id="homeFromParagraphBtn">🏠 דף הבית</button>
            </div>

            <div class="section">
                <h3>📄 פרק נבחר: <span id="selectedChapterTitle"></span></h3>

                <div class="paragraph-selector">
                    <div>
                        <label>פיסקא התחלה:</label>
                        <select id="startParagraph">
                            <option value="">בחר התחלה...</option>
                        </select>
                    </div>
                    <div>
                        <label>פיסקא סוף:</label>
                        <select id="endParagraph">
                            <option value="">בחר סוף...</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- אפשרויות פורמט ופלט -->
            <div class="output-options">
                <h4>⚙️ אפשרויות פורמט:</h4>
                <div class="option-group">
                    <div class="option-item">
                        <label>הוספת קישורים לספריא</label>
                        <input type="checkbox" id="includeLinks" >
                    </div>
                    <div class="option-item">
                        <label>הערות שוליים</label>
                        <input type="checkbox" id="includeFootnotes" checked>
                    </div>
                    <div class="option-item">
                        <label>מספור פיסקאות</label>
                        <input type="checkbox" id="includeParagraphNumbers" checked>
                    </div>
                    <div class="option-item">
                        <label>תאריך וזמן</label>
                        <input type="checkbox" id="includeTimestamp" >
                    </div>
                </div>

                <div class="hyperlink-settings">
                    <label>סוג קישורים:</label>
                    <div class="option-group">
                        <div class="option-item">
                            <label>קישור ישיר לספריא</label>
                            <input type="radio" name="linkType" value="direct" >
                        </div>
                        <div class="option-item">
                            <label>קישורים בהערות שוליים</label>
                            <input type="radio" name="linkType" value="footnotes" checked>
                        </div>
                    </div>
                </div>
            </div>

            <div class="section">
                <h3>📚 גירסאות נוספות:</h3>
                <div id="versionsContainer" class="checkbox-group">
                    <div>בחר פיסקאות תחילה</div>
                </div>
            </div>

            <div class="section">
                <h3>📝 מפרשים:</h3>
                <div id="commentariesContainer" class="checkbox-group">
                    <div>בחר פיסקאות תחילה</div>
                </div>
            </div>

            <button class="generate-btn" id="generateBtn" disabled>📄 צור מסמך </button>
            <div class="loading hidden" id="generateLoading">מייצר מסמך עם קישורים ופירושים</div>
        </div>

        <!-- פאנל דיבוג -->
        <div class="section">
            <h3>🔧 דיבוג:</h3>
            <button class="btn" id="clearDebugBtn">🗑️ נקה</button>
            <div class="debug-panel" id="debugPanel">
                <div>📱 Enhanced Sefaria Navigator started</div>
            </div>
        </div>
    </div>

    <script>
        class EnhancedSefariaNavigator {
            constructor() {
                this.baseUrl = 'https://www.sefaria.org/api';
                this.sefariaBaseUrl = 'https://www.sefaria.org';
                this.currentPath = [];
                this.currentBook = null;
                this.currentSection = null;
                this.currentChapter = null;
                this.bookData = null;
                this.chapterData = null;
                this.commentaryCache = new Map();
                this.footnoteCounter = 1;
                
                this.init();
            }

            init() {
                this.log('🚀 Starting Enhanced Sefaria Navigator...');
                this.setupEventListeners();
                this.loadCategories();
            }

            setupEventListeners() {
                // ניווט
                document.getElementById('backBtn').addEventListener('click', () => this.goBack());
                document.getElementById('homeBtn').addEventListener('click', () => this.goHome());
                document.getElementById('backToBookFromSectionBtn').addEventListener('click', () => this.backToBook());
                document.getElementById('homeFromSectionBtn').addEventListener('click', () => this.goHome());
                document.getElementById('backToSectionBtn').addEventListener('click', () => this.backToSection());
                document.getElementById('backToBookBtn').addEventListener('click', () => this.backToBook());
                document.getElementById('homeFromChapterBtn').addEventListener('click', () => this.goHome());
                document.getElementById('backToChapterBtn').addEventListener('click', () => this.backToChapter());
                document.getElementById('homeFromParagraphBtn').addEventListener('click', () => this.goHome());

                // בחירות
                document.getElementById('sectionSelect').addEventListener('change', () => this.onSectionSelect());
                document.getElementById('chapterSelect').addEventListener('change', () => this.onChapterSelect());
                document.getElementById('startParagraph').addEventListener('change', () => this.onParagraphRangeChange());
                document.getElementById('endParagraph').addEventListener('change', () => this.onParagraphRangeChange());

                // יצירת מסמך
                document.getElementById('generateBtn').addEventListener('click', () => this.generateEnhancedDocument());

                // דיבוג
                document.getElementById('clearDebugBtn').addEventListener('click', () => this.clearDebug());
            }

            // כל הפונקציות הקיימות נשארות אותו דבר עד generateDocument...
            
            goBack() {
                if (this.currentPath.length > 0) {
                    this.currentPath.pop();
                    if (this.currentPath.length === 0) {
                        this.loadCategories();
                    } else {
                        const parent = this.currentPath[this.currentPath.length - 1];
                        this.navigateToCategory(parent);
                        this.currentPath.pop();
                    }
                    this.updateBreadcrumb();
                    this.updateBackButton();
                }
            }

            goHome() {
                this.currentPath = [];
                this.currentBook = null;
                this.currentSection = null;
                this.currentChapter = null;

                document.getElementById('categoriesStep').classList.remove('hidden');
                document.getElementById('sectionStep').classList.add('hidden');
                document.getElementById('chapterStep').classList.add('hidden');
                document.getElementById('paragraphStep').classList.add('hidden');

                this.loadCategories();
                this.updateBreadcrumb();
                this.updateBackButton();

                this.log('🏠 חזרה לדף הבית');
            }

            backToBook() {
                this.currentSection = null;
                document.getElementById('sectionStep').classList.add('hidden');
                document.getElementById('chapterStep').classList.add('hidden');
                document.getElementById('paragraphStep').classList.add('hidden');
                document.getElementById('categoriesStep').classList.remove('hidden');
                this.log('📖 חזרה לבחירת ספר');
            }

            backToSection() {
                document.getElementById('chapterStep').classList.add('hidden');
                document.getElementById('paragraphStep').classList.add('hidden');
                document.getElementById('sectionStep').classList.remove('hidden');
                this.log('📑 חזרה לבחירת סקשן');
            }

            backToChapter() {
                document.getElementById('paragraphStep').classList.add('hidden');
                document.getElementById('chapterStep').classList.remove('hidden');
                this.log('🔢 חזרה לבחירת פרק');
            }

            async loadCategories() {
                try {
                    this.log('📚 Loading categories...');
                    const response = await fetch(`${this.baseUrl}/index`);
                    const data = await response.json();
                    this.displayCategories(data);
                } catch (error) {
                    this.log(`❌ Error loading categories: ${error.message}`, 'error');
                    this.showError('שגיאה בטעינת הקטגוריות');
                }
            }

            displayCategories(categories) {
                const contentArea = document.getElementById('contentArea');
                contentArea.innerHTML = '';

                if (!Array.isArray(categories)) {
                    this.log('❌ Categories is not an array:', categories, 'error');
                    return;
                }

                const grid = document.createElement('div');
                grid.className = 'grid';

                categories.forEach(category => {
                    if (category.category) {
                        const card = this.createCard(
                            category.category,
                            category.heCategory || '',
                            () => this.navigateToCategory(category)
                        );
                        grid.appendChild(card);
                    }
                });

                contentArea.appendChild(grid);
                this.updateBreadcrumb();
            }

            async navigateToCategory(category) {
                try {
                    this.log(`🔍 Navigating to category: ${category.category}`);
                    this.currentPath.push(category);

                    if (category.contents) {
                        this.displayContents(category.contents);
                    } else {
                        const response = await fetch(`${this.baseUrl}/index/${encodeURIComponent(category.category)}`);
                        const data = await response.json();
                        this.displayContents(data.contents || []);
                    }

                    this.updateBreadcrumb();
                    this.updateBackButton();
                } catch (error) {
                    this.log(`❌ Error navigating to category: ${error.message}`, 'error');
                }
            }

            displayContents(contents) {
                const contentArea = document.getElementById('contentArea');
                contentArea.innerHTML = '';

                if (!Array.isArray(contents)) {
                    this.log('❌ Contents is not an array:', contents, 'error');
                    return;
                }

                const grid = document.createElement('div');
                grid.className = 'grid';

                contents.forEach(item => {
                    if (item.category) {
                        const card = this.createCard(
                            item.category,
                            item.heCategory || '',
                            () => this.navigateToCategory(item)
                        );
                        grid.appendChild(card);
                    } else if (item.title) {
                        const card = this.createCard(
                            item.title,
                            item.heTitle || '',
                            () => this.selectBook(item)
                        );
                        card.classList.add('book-card');
                        grid.appendChild(card);
                    }
                });

                contentArea.appendChild(grid);
            }

            createCard(title, subtitle, onClick) {
                const card = document.createElement('div');
                card.className = 'card';
                card.onclick = onClick;

                const titleEl = document.createElement('div');
                titleEl.className = 'card-title';
                titleEl.textContent = subtitle;

                const subtitleEl = document.createElement('div');
                subtitleEl.className = 'card-subtitle';
                subtitleEl.textContent = title;

                card.appendChild(titleEl);
                card.appendChild(subtitleEl);

                return card;
            }

            async selectBook(book) {
                try {
                    this.log(`📖 Selected book: ${book.title}`);
                    this.currentBook = book;
                    
                    this.commentaryCache.clear();
                    this.log('🧹 Cleared commentary cache');

                    const v2Response = await fetch(`${this.baseUrl}/v2/raw/index/${encodeURIComponent(book.title)}`);
                    this.bookData = await v2Response.json();
                    
                    if (this.bookData.schema && this.bookData.schema.nodes && this.bookData.schema.nodes.length > 0) {
                        this.log(`📚 Complex book with ${this.bookData.schema.nodes.length} sections`);
                        this.showSectionStep();
                    } else {
                        this.log('📖 Simple book structure');
                        this.showChapterStep();
                        this.populateChapters();
                    }
                } catch (error) {
                    this.log(`❌ Error selecting book: ${error.message}`, 'error');
                    this.showError('שגיאה בטעינת הספר');
                }
            }

            showSectionStep() {
                document.getElementById('categoriesStep').classList.add('hidden');
                document.getElementById('sectionStep').classList.remove('hidden');
                document.getElementById('selectedBookTitleSection').textContent = this.currentBook.heTitle || this.currentBook.title;
                this.populateSections();
            }

            populateSections() {
                const sectionSelect = document.getElementById('sectionSelect');
                sectionSelect.innerHTML = '<option value="">בחר חלק...</option>';

                if (this.bookData.schema && this.bookData.schema.nodes) {
                    this.bookData.schema.nodes.forEach((section, index) => {
                        const option = document.createElement('option');
                        option.value = section.key || section.title;
                        option.textContent = section.titles[1].text || section.title;
                        option.dataset.index = index;
                        sectionSelect.appendChild(option);
                    });
                    this.log(`📑 Added ${this.bookData.schema.nodes.length} sections`);
                }
            }

            async onSectionSelect() {
                const sectionSelect = document.getElementById('sectionSelect');
                const selectedOption = sectionSelect.options[sectionSelect.selectedIndex];

                if (!selectedOption.value) return;

                this.currentSection = {
                    key: selectedOption.value,
                    index: parseInt(selectedOption.dataset.index),
                    title: selectedOption.textContent,
                    data: this.bookData.schema.nodes[selectedOption.dataset.index],
                };

                this.log(`📑 Selected section: ${this.currentSection.title}`, this.currentSection);
                this.showChapterStep();
                this.populateChaptersForSection();
            }

            populateChaptersForSection() {
                const chapterSelect = document.getElementById('chapterSelect');
                chapterSelect.innerHTML = '<option value="">בחר פרק...</option>';

                const sectionData = this.currentSection.data;

                if (sectionData.index_offsets_by_depth && sectionData.index_offsets_by_depth["2"]) {
                    const offsets = sectionData.index_offsets_by_depth["2"];
                    const numChapters = offsets.length;

                    this.log(`📖 Section has ${numChapters} chapters`);

                    for (let i = 1; i <= numChapters; i++) {
                        const option = document.createElement('option');
                        option.value = i;
                        option.textContent = `פרק ${i}`;
                        chapterSelect.appendChild(option);
                    }

                    document.getElementById('selectedSectionTitle').classList.remove('hidden');
                    document.getElementById('selectedSectionName').textContent = this.currentSection.title;
                } else {
                    this.log('❌ No chapter information found for section', 'error');
                }
            }

            showChapterStep() {
                document.getElementById('categoriesStep').classList.add('hidden');
                document.getElementById('sectionStep').classList.add('hidden');
                document.getElementById('chapterStep').classList.remove('hidden');
                document.getElementById('selectedBookTitle').textContent = this.currentBook.heTitle || this.currentBook.title;

                if (this.currentSection) {
                    document.getElementById('selectedSectionTitle').classList.remove('hidden');
                    document.getElementById('selectedSectionName').textContent = this.currentSection.title;
                    document.getElementById('backToSectionBtn').style.display = 'inline-block';
                } else {
                    document.getElementById('selectedSectionTitle').classList.add('hidden');
                    document.getElementById('backToSectionBtn').style.display = 'none';
                }
            }

            populateChapters() {
                const chapterSelect = document.getElementById('chapterSelect');
                chapterSelect.innerHTML = '<option value="">בחר פרק...</option>';

                let chapterCount = 0;
                
                this.log('📊 Book structure:', this.bookData);
                
                if (this.bookData.schema && this.bookData.schema.lengths && this.bookData.schema.lengths.length > 0) {
                    chapterCount = this.bookData.schema.lengths[0];
                    this.log(`📚 Using schema.lengths: ${chapterCount} chapters`);
                } else if (this.bookData.schema && this.bookData.schema.content_counts && this.bookData.schema.content_counts.length > 0) {
                    chapterCount = this.bookData.schema.content_counts.length;
                    this.log(`📚 Using schema.content_counts: ${chapterCount} chapters`);
                } else if (this.bookData.lengths && this.bookData.lengths.length > 0) {
                    chapterCount = this.bookData.lengths[0];
                    this.log(`📚 Using book.lengths: ${chapterCount} chapters`);
                } else if (this.bookData.alt_structs && this.bookData.alt_structs.Parasha && this.bookData.alt_structs.Parasha.nodes) {
                    chapterCount = this.estimateChaptersFromParashiot(this.bookData.alt_structs.Parasha.nodes);
                    this.log(`📚 Estimated from Parashot: ${chapterCount} chapters`);
                } else {
                    chapterCount = 50;
                    this.log(`📚 Using default chapter count: ${chapterCount}`);
                }
                
                for (let i = 1; i <= chapterCount; i++) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = `פרק ${i}`;
                    chapterSelect.appendChild(option);
                }
                
                this.log(`📚 Added ${chapterCount} chapters to select menu`);
            }

            estimateChaptersFromParashiot(parashiot) {
                try {
                    let maxChapter = 0;
                    
                    for (const parasha of parashiot) {
                        if (parasha.wholeRef) {
                            const match = parasha.wholeRef.match(/(\d+):(\d+)-(\d+):(\d+)/);
                            if (match && match[3]) {
                                const endChapter = parseInt(match[3]);
                                if (endChapter > maxChapter) {
                                    maxChapter = endChapter;
                                }
                            }
                        }
                    }
                    
                    return maxChapter || 50;
                } catch (error) {
                    this.log(`❌ Error estimating chapters from parashiot: ${error.message}`, 'error');
                    return 50;
                }
            }

            async onChapterSelect() {
                const chapterNum = document.getElementById('chapterSelect').value;
                if (!chapterNum) return;

                try {
                    this.log(`📄 Loading chapter ${chapterNum}`);
                    this.currentChapter = chapterNum;

                    let chapterRef;
                    if (this.currentSection) {
                        chapterRef = `${this.currentBook.title}, ${this.currentSection.key} ${chapterNum}`;
                    } else {
                        chapterRef = `${this.currentBook.title} ${chapterNum}`;
                    }

                    this.log(`🔗 Chapter reference: ${chapterRef}`);

                    const chapterInfoResponse = await fetch(`${this.baseUrl}/texts/${encodeURIComponent(chapterRef)}`);
                    const chapterInfo = await chapterInfoResponse.json();

                    this.chapterInfo = {
                        heTitle: chapterInfo.heTitle || '',
                        heSectionRef: chapterInfo.heSectionRef || '',
                        bookTitle: chapterInfo.book || this.currentBook.title,
                        heBook: chapterInfo.heBook || '',
                        offset: chapterInfo.index_offsets_by_depth?.["2"]?.[0] || 0
                    };

                    const isSimpleBook = !this.currentSection;
                    if (isSimpleBook && chapterInfo.he && Array.isArray(chapterInfo.he)) {
                        this.chapterData = chapterInfo;
                        this.log('📚 Direct use of chapter data for simple book');
                    } else {
                        await this.loadParagraphByParagraph(chapterRef);
                    }

                    this.showParagraphStep();
                    this.populateParagraphs();
                } catch (error) {
                    this.log(`❌ Error loading chapter: ${error.message}`, 'error');
                    this.showError('שגיאה בטעינת הפרק');
                }
            }

            async loadParagraphByParagraph(chapterRef) {
                this.log(`📝 Loading paragraphs for: ${chapterRef}`);
                
                const isSimpleBook = !this.currentSection;
                
                if (isSimpleBook) {
                    try {
                        this.log(`📚 Loading entire chapter at once for simple book: ${chapterRef}`);
                        const response = await fetch(`${this.baseUrl}/texts/${encodeURIComponent(chapterRef)}`);
                        
                        if (response.ok) {
                            const chapterData = await response.json();
                            
                            if (chapterData.he && Array.isArray(chapterData.he)) {
                                this.chapterData = chapterData;
                                this.log(`✅ Successfully loaded ${chapterData.he.length} paragraphs at once`);
                                return;
                            } else {
                                this.log(`⚠️ Unexpected format for chapter data`);
                            }
                        } else {
                            this.log(`❌ Failed to load chapter: ${response.status}`);
                        }
                    } catch (error) {
                        this.log(`❌ Error loading full chapter: ${error.message}`);
                    }
                }

                const chapterNum = parseInt(this.currentChapter);
                let expectedParagraphs = this.getExpectedParagraphCount(chapterNum);
                
                if (expectedParagraphs) {
                    this.log(`📊 Expected ${expectedParagraphs} paragraphs for chapter ${chapterNum}`);
                    await this.loadExactParagraphCount(chapterRef, expectedParagraphs);
                } else {
                    this.log('📊 No expected count, using discovery method');
                    await this.loadParagraphsDiscovery(chapterRef);
                }
            }

            getExpectedParagraphCount(chapterNum) {
                let counts = null;

                if (this.currentSection && this.currentSection.data.content_counts) {
                    counts = this.currentSection.data.content_counts;
                } else if (this.bookData.schema && this.bookData.schema.content_counts) {
                    counts = this.bookData.schema.content_counts;
                } else if (this.bookData.schema && this.bookData.schema.lengths) {
                    counts = this.bookData.schema.lengths;
                } else if (this.bookData.lengths && this.bookData.lengths.length > 1) {
                    counts = this.bookData.lengths[1];
                }

                if (counts && Array.isArray(counts) && counts[chapterNum - 1]) {
                    return counts[chapterNum - 1];
                }

                return null;
            }

            async loadExactParagraphCount(chapterRef, expectedCount) {
                this.log(`📚 Loading ${expectedCount} paragraphs exactly`);

                this.chapterData = { he: [] };

                for (let paragraphNum = 1; paragraphNum <= expectedCount; paragraphNum++) {
                    const paragraphRef = `${chapterRef}:${paragraphNum}`;

                    try {
                        this.log(`📄 Loading paragraph ${paragraphNum}/${expectedCount}: ${paragraphRef}`);

                        const response = await fetch(`${this.baseUrl}/texts/${encodeURIComponent(paragraphRef)}`);

                        if (response.ok) {
                            const paragraphData = await response.json();

                            if (paragraphData.he) {
                                const paragraphText = Array.isArray(paragraphData.he) ?
                                    paragraphData.he[0] || paragraphData.he.join(' ') : paragraphData.he;

                                if (paragraphText && paragraphText.trim()) {
                                    this.chapterData.he.push(paragraphText);
                                    this.log(`✅ Loaded paragraph ${paragraphNum}: ${paragraphText.substring(0, 50)}...`);
                                } else {
                                    this.chapterData.he.push('');
                                    this.log(`⚠️ Empty paragraph ${paragraphNum}`);
                                }
                            } else {
                                this.chapterData.he.push('');
                                this.log(`⚠️ No Hebrew text for paragraph ${paragraphNum}`);
                            }
                        } else {
                            this.chapterData.he.push('');
                            this.log(`❌ Failed to load paragraph ${paragraphNum}: ${response.status}`);
                        }

                        await new Promise(resolve => setTimeout(resolve, 100));

                    } catch (error) {
                        this.log(`❌ Error loading paragraph ${paragraphNum}: ${error.message}`);
                        this.chapterData.he.push('');
                    }
                }

                while (this.chapterData.he.length > 0 && !this.chapterData.he[this.chapterData.he.length - 1].trim()) {
                    this.chapterData.he.pop();
                }

                this.log(`📊 Loaded ${this.chapterData.he.length} paragraphs out of ${expectedCount} expected`);
            }

            async loadParagraphsDiscovery(chapterRef) {
                this.log(`🔍 Discovering paragraphs for: ${chapterRef}`);

                try {
                    const fullChapterResponse = await fetch(`${this.baseUrl}/texts/${encodeURIComponent(chapterRef)}`);

                    if (fullChapterResponse.ok) {
                        const fullChapterData = await fullChapterResponse.json();

                        if (fullChapterData.he && Array.isArray(fullChapterData.he)) {
                            this.chapterData = fullChapterData;
                            this.log(`✅ Loaded ${fullChapterData.he.length} paragraphs from full chapter`);
                            return;
                        }
                    }
                } catch (error) {
                    this.log(`❌ Error loading full chapter: ${error.message}`);
                }

                await this.discoverExistingParagraphs(chapterRef);
            }

            async discoverExistingParagraphs(chapterRef) {
                this.log(`🔍 Discovering existing paragraphs for: ${chapterRef}`);

                this.chapterData = { he: [] };
                const maxAttempts = 200;
                const maxFailures = 10;
                let consecutiveFailures = 0;

                for (let paragraphNum = 1; paragraphNum <= maxAttempts; paragraphNum++) {
                    const paragraphRef = `${chapterRef}:${paragraphNum}`;

                    try {
                        this.log(`🔍 Trying paragraph ${paragraphNum}`);

                        const response = await fetch(`${this.baseUrl}/texts/${encodeURIComponent(paragraphRef)}`);

                        if (response.ok) {
                            const paragraphData = await response.json();

                            if (paragraphData.he && paragraphData.he.length > 0) {
                                const paragraphText = Array.isArray(paragraphData.he) ?
                                    paragraphData.he[0] : paragraphData.he;

                                if (paragraphText && paragraphText.trim()) {
                                    this.chapterData.he.push(paragraphText);
                                    this.log(`✅ Found paragraph ${paragraphNum}`);
                                    consecutiveFailures = 0;
                                } else {
                                    consecutiveFailures++;
                                }
                            } else {
                                consecutiveFailures++;
                            }
                        } else if (response.status === 404) {
                            consecutiveFailures++;
                            this.log(`⏭️ Paragraph ${paragraphNum} not found (404)`);
                        } else {
                            consecutiveFailures++;
                            this.log(`❌ Error ${response.status} for paragraph ${paragraphNum}`);
                        }

                        if (consecutiveFailures >= maxFailures) {
                            this.log(`🛑 Stopping after ${maxFailures} consecutive failures`);
                            break;
                        }

                        await new Promise(resolve => setTimeout(resolve, 50));

                    } catch (error) {
                        this.log(`❌ Error fetching paragraph ${paragraphNum}: ${error.message}`);
                        consecutiveFailures++;

                        if (consecutiveFailures >= maxFailures) {
                            break;
                        }
                    }
                }

                this.log(`📊 Discovery complete: ${this.chapterData.he.length} paragraphs found`);

                if (this.chapterData.he.length === 0) {
                    this.log('⚠️ No paragraphs found, trying final fallback');
                    await this.loadChapterFallback(chapterRef);
                }
            }

            async loadChapterFallback(chapterRef) {
                try {
                    const response = await fetch(`${this.baseUrl}/texts/${encodeURIComponent(chapterRef)}`);
                    const data = await response.json();

                    if (data.he && Array.isArray(data.he)) {
                        this.chapterData = data;
                        this.log(`📚 Fallback: loaded ${data.he.length} paragraphs from full chapter`);
                    } else if (data.he) {
                        this.chapterData = { he: [data.he] };
                        this.log('📚 Fallback: loaded single paragraph');
                    }
                } catch (error) {
                    this.log(`❌ Fallback also failed: ${error.message}`, 'error');
                }
            }

            showParagraphStep() {
                document.getElementById('chapterStep').classList.add('hidden');
                document.getElementById('paragraphStep').classList.remove('hidden');

                let title = `${this.currentBook.heTitle || this.currentBook.title}`;
                if (this.currentSection) {
                    title += `, ${this.currentSection.title}`;
                }
                title += ` פרק ${this.currentChapter}`;

                document.getElementById('selectedChapterTitle').textContent = title;
            }

            async onParagraphRangeChange() {
                const start = document.getElementById('startParagraph').value;
                const end = document.getElementById('endParagraph').value;

                if (start && end) {
                    this.log(`📝 Paragraph range selected: ${start} to ${end}`);

                    await this.loadVersions();
                    await this.loadCommentaries();

                    document.getElementById('generateBtn').disabled = false;
                } else {
                    document.getElementById('generateBtn').disabled = true;
                }
            }

            async loadVersions() {
                try {
                    this.log('📚 Loading versions...');
                    const response = await fetch(`${this.baseUrl}/texts/versions/${encodeURIComponent(this.currentBook.title)}`);
                    const versions = await response.json();

                    const container = document.getElementById('versionsContainer');
                    container.innerHTML = '';

                    if (Array.isArray(versions)) {
                        versions.forEach(version => {
                            if (version.languageFamilyName !== 'hebrew' || !version.isPrimary) {
                                const label = document.createElement('label');
                                const checkbox = document.createElement('input');
                                checkbox.type = 'checkbox';
                                checkbox.value = version.versionTitle;
                                checkbox.dataset.language = version.languageFamilyName;
                                checkbox.dataset.title = version.versionTitle;

                                label.appendChild(checkbox);
                                label.appendChild(document.createTextNode(`${version.versionTitle} (${version.languageFamilyName})`));
                                container.appendChild(label);
                            }
                        });
                    }
                } catch (error) {
                    this.log(`❌ Error loading versions: ${error.message}`, 'error');
                }
            }

            populateParagraphs() {
                const startSelect = document.getElementById('startParagraph');
                const endSelect = document.getElementById('endParagraph');
                
                startSelect.innerHTML = '<option value="">בחר התחלה...</option>';
                endSelect.innerHTML = '<option value="">בחר סוף...</option>';

                if (this.chapterData.he && Array.isArray(this.chapterData.he)) {
                    const numParagraphs = this.chapterData.he.length;
                    this.log(`📝 Chapter has ${numParagraphs} paragraphs`);

                    const paraLabel = this.currentSection ? 'פיסקא' : 'פסוק';
                    
                    let offset = 0;
                    
                    if (this.chapterInfo && this.chapterInfo.offset !== undefined) {
                        offset = this.chapterInfo.offset;
                        this.log(`📊 Using API offset: ${offset}`);
                    } else {
                        this.log(`📊 No offset available, using 0`);
                    }

                    for (let i = 1; i <= numParagraphs; i++) {
                        const displayNumber = i + offset;
                        
                        const startOption = document.createElement('option');
                        startOption.value = displayNumber;
                        startOption.textContent = `${paraLabel} ${displayNumber}`;
                        startSelect.appendChild(startOption);

                        const endOption = document.createElement('option');
                        endOption.value = displayNumber;
                        endOption.textContent = `${paraLabel} ${displayNumber}`;
                        endSelect.appendChild(endOption);
                    }
                    
                    this.log('🔧 Re-ensuring event listeners for paragraph selects');
                    startSelect.removeEventListener('change', this.onParagraphRangeChange.bind(this));
                    endSelect.removeEventListener('change', this.onParagraphRangeChange.bind(this));
                    startSelect.addEventListener('change', this.onParagraphRangeChange.bind(this));
                    endSelect.addEventListener('change', this.onParagraphRangeChange.bind(this));
                    
                } else {
                    this.log('❌ No paragraph data found in chapter', 'error');
                    
                    for (let i = 1; i <= 10; i++) {
                        const startOption = document.createElement('option');
                        startOption.value = i;
                        startOption.textContent = `פסוק ${i}`;
                        startSelect.appendChild(startOption);

                        const endOption = document.createElement('option');
                        endOption.value = i;
                        endOption.textContent = `פסוק ${i}`;
                        endSelect.appendChild(endOption);
                    }
                }
            }

            async loadCommentaries() {
                try {
                    this.log('📝 Loading commentaries...');
                    const start = document.getElementById('startParagraph').value;

                    if (!start) {
                        document.getElementById('commentariesContainer').innerHTML = '<div>בחר פיסקאות תחילה</div>';
                        return;
                    }

                    let sampleRef;
                    if (this.currentSection) {
                        sampleRef = `${this.currentBook.title}, ${this.currentSection.key} ${this.currentChapter}:${start}`;
                    } else {
                        sampleRef = `${this.currentBook.title} ${this.currentChapter}:${start}`;
                    }

                    this.log(`🔗 Sample commentary reference: ${sampleRef}`);

                    const commentaries = await this.discoverCommentaries(sampleRef);

                    const container = document.getElementById('commentariesContainer');
                    container.innerHTML = '';

                    if (commentaries.size > 0) {
                        commentaries.forEach(title => {
                            const label = document.createElement('label');
                            const checkbox = document.createElement('input');
                            checkbox.type = 'checkbox';
                            checkbox.value = title;

                            label.appendChild(checkbox);
                            label.appendChild(document.createTextNode(title));
                            container.appendChild(label);
                        });

                        this.log(`✅ Found ${commentaries.size} commentaries`);
                    } else {
                        container.innerHTML = '<div>לא נמצאו מפרשים זמינים</div>';
                        this.log('❌ No commentaries found');
                    }
                } catch (error) {
                    this.log(`❌ Error loading commentaries: ${error.message}`, 'error');
                    document.getElementById('commentariesContainer').innerHTML = '<div>שגיאה בטעינת מפרשים</div>';
                }
            }

            async discoverCommentaries(ref) {
                const commentaries = new Set();

                try {
                    const response = await fetch(`${this.baseUrl}/links/${encodeURIComponent(ref)}`);

                    if (response.ok) {
                        const links = await response.json();

                        if (Array.isArray(links)) {
                            links.forEach(link => {
                                if (link.category === 'Commentary' && link.collectiveTitle) {
                                    const title = link.collectiveTitle.he || link.collectiveTitle.en;
                                    if (title) {
                                        commentaries.add(title);
                                        this.log(`📝 Found commentary: ${title}`);
                                    }
                                }
                            });
                        }
                    }
                } catch (error) {
                    this.log(`❌ Error fetching links: ${error.message}`);
                }

                if (commentaries.size === 0) {
                    this.log('🔍 No links found, trying known commentaries');
                }

                return commentaries;
            }

            // הפונקציה המשופרת ליצירת מסמך עם קישורים
            async generateEnhancedDocument() {
                try {
                    this.log('📄 Generating enhanced document...');
                    document.getElementById('generateBtn').disabled = true;
                    document.getElementById('generateLoading').classList.remove('hidden');

                    const start = parseInt(document.getElementById('startParagraph').value);
                    const end = parseInt(document.getElementById('endParagraph').value);

                    // איסוף אפשרויות פורמט
                    const includeLinks = document.getElementById('includeLinks').unchecked;
                    const includeFootnotes = document.getElementById('includeFootnotes').checked;
                    const includeParagraphNumbers = document.getElementById('includeParagraphNumbers').checked;
                    const includeTimestamp = document.getElementById('includeTimestamp').unchecked;
                    const linkType = document.querySelector('input[name="linkType"]:checked').value;

                    // איסוף הגירסאות הנבחרות
                    const selectedVersions = Array.from(document.querySelectorAll('#versionsContainer input[type="checkbox"]:checked'))
                        .map(cb => ({
                            title: cb.dataset.title,
                            language: cb.dataset.language
                        }))
                        .filter(v => v.title && v.language);

                    // איסוף המפרשים הנבחרים
                    const selectedCommentaries = Array.from(document.querySelectorAll('#commentariesContainer input:checked'))
                        .map(cb => cb.value);

                    this.log(`📊 Selected range: ${start} to ${end}`);
                    this.log(`📚 Selected versions:`, selectedVersions);
                    this.log(`📝 Selected commentaries: ${selectedCommentaries.join(', ') || 'none'}`);

                    // שלוף את כל הפיסקאות בטווח
                    const documentData = await this.fetchDocumentData(start, end, selectedVersions, selectedCommentaries);

                    // יצור קובץ Word משופר
                    this.createEnhancedWordDocument(documentData, {
                        includeLinks,
                        includeFootnotes,
                        includeParagraphNumbers,
                        includeTimestamp,
                        linkType
                    });

                    this.log('✅ Enhanced document generated successfully!', 'success');
                    this.showSuccess('המסמך המתקדם נוצר בהצלחה עם קישורים ופירושים!');

                } catch (error) {
                    this.log(`❌ Error generating enhanced document: ${error.message}`, 'error');
                    this.showError('שגיאה ביצירת המסמך המתקדם');
                } finally {
                    document.getElementById('generateBtn').disabled = false;
                    document.getElementById('generateLoading').classList.add('hidden');
                }
            }

            async fetchDocumentData(startParagraph, endParagraph, selectedVersions, selectedCommentaries) {
                const documentData = [];

                this.log(`📚 Processing paragraphs ${startParagraph} to ${endParagraph}`);

                for (let index = startParagraph; index <= endParagraph; index++) {
                    this.log(`📄 Processing paragraph ${index}`);

                    const offset = this.chapterInfo.offset || 0;
                    const arrayIndex = index - offset - 1;
                    
                    this.log(`📊 Array index for paragraph ${index}: ${arrayIndex} (offset: ${offset})`);
                    
                    if (arrayIndex < 0 || arrayIndex >= this.chapterData.he.length) {
                        this.log(`⚠️ Invalid array index ${arrayIndex} for paragraph ${index}`);
                        continue;
                    }

                    const hebrewText = this.chapterData.he[arrayIndex];
                    
                    let paragraphRef;
                    if (this.currentSection) {
                        paragraphRef = `${this.currentBook.title}, ${this.currentSection.key} ${this.currentChapter}:${index}`;
                    } else {
                        paragraphRef = `${this.currentBook.title} ${this.currentChapter}:${index}`;
                    }
                    
                    this.log(`🔗 Paragraph reference: ${paragraphRef}`);
                    
                    try {
                        const cleanText = hebrewText.trim();

                        if (!cleanText || cleanText.replace(/<[^>]*>/g, '').trim() === '') {
                            this.log(`⚠️ Empty text for paragraph ${index}`);
                            continue;
                        }

                        // שלוף מפרשים לפיסקא זו
                        const commentaries = await this.fetchCommentariesForParagraph(paragraphRef, selectedCommentaries);

                        // שלוף גירסאות נוספות
                        const additionalVersions = await this.fetchAdditionalVersionsEfficient(paragraphRef, selectedVersions, arrayIndex);

                        // יצירת קישור לספריא
                        const sefariaLink = this.createSefariaLink(paragraphRef);

                        documentData.push({
                            paragraphNum: index,
                            ref: paragraphRef,
                            hebrewText: cleanText,
                            additionalVersions,
                            commentaries,
                            sefariaLink
                        });

                        this.log(`✅ Added paragraph ${index} with ${commentaries.length} commentaries and link: ${sefariaLink}`);

                    } catch (error) {
                        this.log(`❌ Error processing paragraph ${index}: ${error.message}`, 'error');
                    }

                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                this.log(`🎉 Document data ready: ${documentData.length} paragraphs`);
                return documentData;
            }

            createSefariaLink(ref) {
                // יצירת קישור ישיר לספריא
                const encodedRef = encodeURIComponent(ref.replace(/,/g, ''));
                return `${this.sefariaBaseUrl}/${encodedRef}`;
            }

            async fetchCommentariesForParagraph(ref, selectedCommentaries) {
                if (selectedCommentaries.length === 0) return [];

                try {
                    this.log(`📝 Fetching commentaries for: ${ref}`);

                    const response = await fetch(`${this.baseUrl}/links/${encodeURIComponent(ref)}`);
                    const links = await response.json();

                    const commentaries = [];

                    if (Array.isArray(links)) {
                        for (const link of links) {
                            if (link.category === 'Commentary' && link.collectiveTitle) {
                                const commentaryTitle = link.collectiveTitle.he || link.collectiveTitle.en;

                                if (selectedCommentaries.includes(commentaryTitle)) {
                                    this.log(`🔍 Processing commentary: ${commentaryTitle} -> ${link.sourceRef}`);

                                    const commentaryText = await this.fetchCommentaryTextSmart(link.sourceRef, ref);
                                    if (commentaryText) {
                                        commentaries.push({
                                            title: commentaryTitle,
                                            text: commentaryText,
                                            ref: link.sourceRef,
                                            link: this.createSefariaLink(link.sourceRef)
                                        });
                                        this.log(`✅ Added commentary: ${commentaryTitle} (${commentaryText.length} chars)`);
                                    }
                                }
                            }
                        }
                    }

                    return commentaries;
                } catch (error) {
                    this.log(`❌ Error fetching commentaries for ${ref}: ${error.message}`, 'error');
                    return [];
                }
            }

            async fetchCommentaryTextSmart(commentaryRef, originalRef) {
                try {
                    this.log(`📖 Fetching commentary smartly: ${commentaryRef}`);

                    const { baseRef, paragraphNum } = this.parseCommentaryRef(commentaryRef, originalRef);

                    this.log(`🔍 Parsed: baseRef=${baseRef}, paragraphNum=${paragraphNum}`);

                    const response = await fetch(`${this.baseUrl}/texts/${encodeURIComponent(baseRef)}`);
                    const data = await response.json();

                    this.log(`📊 Commentary data for ${baseRef}:`, data);

                    let text = '';

                    if (data.he && Array.isArray(data.he) && paragraphNum !== null) {
                        const paragraphIndex = paragraphNum - 1;
                        if (paragraphIndex >= 0 && paragraphIndex < data.he.length) {
                            text = data.he[paragraphIndex];
                            this.log(`✅ Found specific paragraph ${paragraphNum}: ${text.substring(0, 100)}...`);
                        } else {
                            this.log(`❌ Paragraph ${paragraphNum} not found in array of ${data.he.length} items`);
                        }
                    } else if (data.he) {
                        if (Array.isArray(data.he)) {
                            text = data.he.join(' ');
                        } else {
                            text = data.he;
                        }
                        this.log(`📄 Using full commentary text (${text.length} chars)`);
                    } else if (data.text) {
                        if (Array.isArray(data.text)) {
                            text = data.text.join(' ');
                        } else {
                            text = data.text;
                        }
                    }

                    if (text) {
                        text = text.replace(/<[^>]*>/g, '').trim();
                    }

                    this.log(`📝 Final commentary text (${text.length} chars): ${text.substring(0, 100)}...`);
                    return text;

                } catch (error) {
                    this.log(`❌ Error fetching commentary text: ${error.message}`, 'error');
                    return '';
                }
            }

            parseCommentaryRef(commentaryRef, originalRef) {
                try {
                    const parts = commentaryRef.split(':');

                    if (parts.length >= 3) {
                        const paragraphNum = parseInt(parts[parts.length - 1]);
                        const baseRef = parts.slice(0, -1).join(':');

                        if (!isNaN(paragraphNum)) {
                            return { baseRef, paragraphNum };
                        }
                    }

                    return { baseRef: commentaryRef, paragraphNum: null };

                } catch (error) {
                    this.log(`❌ Error parsing commentary ref: ${error.message}`);
                    return { baseRef: commentaryRef, paragraphNum: null };
                }
            }

            async fetchAdditionalVersionsEfficient(ref, selectedVersions, arrayIndex) {
                if (!selectedVersions || selectedVersions.length === 0) {
                    return [];
                }

                this.log(`📚 Fetching additional versions for: ${ref}`);
                const versions = [];

                for (const version of selectedVersions) {
                    try {
                        if (!version.title || !version.language) {
                            this.log(`⚠️ Skipping invalid version:`, version);
                            continue;
                        }
                        
                        this.log(`🔍 Fetching version: ${version.title} (${version.language})`);
                        
                        const cacheKey = `${this.currentChapter}_${version.title}`;
                        
                        let versionChapterData = this.commentaryCache.get(cacheKey);
                        
                        if (!versionChapterData) {
                            const chapterRef = ref.split(':')[0];
                            const encodedRef = encodeURIComponent(chapterRef);
                            const versionParam = encodeURIComponent(`${version.language}|${version.title}`);
                            const url = `${this.baseUrl}/v3/texts/${encodedRef}?version=${versionParam}`;
                            
                            this.log(`🌐 Version URL for whole chapter: ${url}`);
                            
                            const response = await fetch(url);
                            
                            if (response.ok) {
                                versionChapterData = await response.json();
                                this.log(`📊 Version chapter data for ${version.title}:`, versionChapterData);
                                
                                this.commentaryCache.set(cacheKey, versionChapterData);
                            } else {
                                this.log(`❌ Failed to fetch version ${version.title}: ${response.status}`);
                                continue;
                            }
                        } else {
                            this.log(`📋 Using cached chapter data for version: ${version.title}`);
                        }
                        
                        let versionText = '';
                        if (versionChapterData.versions && versionChapterData.versions[0] && versionChapterData.versions[0].text) {
                            versionText = versionChapterData.versions[0].text[arrayIndex];
                            this.log(`📄 Found text for ${version.title}`);
                        }
                        
                        if (!versionText) {
                            this.log(`⚠️ No text found for version ${version.title} at index ${arrayIndex}`);
                            continue;
                        }
                        
                        if (versionText && versionText.trim()) {
                            versionText = versionText.replace(/<[^>]*>/g, '').trim();
                            
                            versions.push({
                                title: version.title,
                                heTitle: versionChapterData.versions[0].versionTitleInHebrew || '',
                                language: version.language,
                                text: versionText,
                                link: this.createSefariaLink(ref) + `?v${version.language}=${encodeURIComponent(version.title)}`
                            });
                            
                            this.log(`✅ Added version: ${version.title} (${versionText.length} chars)`);
                        } else {
                            this.log(`⚠️ No text found for version ${version.title} at index ${arrayIndex}`);
                        }
                        
                    } catch (error) {
                        this.log(`❌ Error fetching version ${version.title}: ${error.message}`, 'error');
                    }
                }

                this.log(`📚 Fetched ${versions.length} additional versions`);
                return versions;
            }

 // החלפת הפונקציה createEnhancedWordDocument
createEnhancedWordDocument(documentData, options) {
    this.footnoteCounter = 1;
    this.endnoteCounter = 1;
    let footnotes = [];
    
    // יצירת כותרת המסמך
    let title = `${this.currentBook.heTitle || this.currentBook.title}`;
    if (this.currentSection) {
        title += `, ${this.currentSection.title}`;
    }
    title += ` פרק ${this.currentChapter}`;
    
    if (documentData.length > 0) {
        const firstParagraph = documentData[0].paragraphNum;
        const lastParagraph = documentData[documentData.length - 1].paragraphNum;
        if (firstParagraph === lastParagraph) {
            title += ` פיסקא ${firstParagraph}`;
        } else {
            title += ` פיסקאות ${firstParagraph}-${lastParagraph}`;
        }
    }

    let html = `
    <!DOCTYPE html>
    <html dir="rtl" lang="he">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <title>${title}</title>
        <style>
            body { 
                font-family: 'David', 'Times New Roman', serif; 
                direction: rtl; 
                text-align: right;
                line-height: 1.8;
                margin: 0.7cm;
                font-size: 14pt;
            }
            .main-title { 
                font-size: 24pt; 
                font-weight: bold; 
                text-align: center; 
                margin-bottom: 30px;
                border-bottom: 2px solid #333;
                padding-bottom: 15px;
                color: #2c5530;
            }
            .document-info {
                background-color: #f8f9fa;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 25px;
                border-right: 4px solid #6b9080;
                font-size: 12pt;
            }
            .paragraph-container { 
                margin-bottom: 35px; 
                padding: 20px;
                border: 1px solid #ddd;
                border-radius: 8px;
                background-color: #fafafa;
            }
            .paragraph-header { 
                font-size: 14pt; 
                font-weight: bold; 
                color: #2c5530;
                margin-bottom: 12px;
                background-color: #e8f5e8;
                padding: 8px 12px;
                border-radius: 5px;
                border-right: 3px solid #4a7c59;
            }
            .paragraph-number {
                background-color: #4a7c59;
                color: white;
                padding: 4px 8px;
                border-radius: 50%;
                font-weight: bold;
                margin-left: 10px;
                font-size: 12pt;
            }
            .paragraph-text { 
                font-size: 16pt; 
                font-weight: bold; 
                margin-bottom: 20px;
                color: #1a1a1a;
            }
            .sefaria-link {
                color: #4a7c59;
                text-decoration: none;
                font-weight: bold;
                border-bottom: 1px dotted #4a7c59;
            }
            .sefaria-link:hover {
                color: #2c5530;
                background-color: #f0f8f0;
            }
            .additional-versions-section {
                margin-top: 20px;
                padding-top: 15px;
                border-top: 2px solid #e0e0e0;
            }
            .versions-title {
                font-weight: bold;
                color: #4a7c59;
                margin-bottom: 15px;
                font-size: 14pt;
            }
            .additional-version {
                margin: 15px 0;
                padding: 15px;
                background-color: #f0f8ff;
                border-right: 4px solid #4682b4;
                border-radius: 5px;
            }
            .version-title {
                font-weight: bold;
                color: #4682b4;
                margin-bottom: 8px;
                font-size: 13pt;
            }
            .version-text {
                font-size: 14pt;
                color: #2c3e50;
                line-height: 1.7;
            }
            
            /* עיצוב פירושים מקומיים תחת הפיסקה */
            .paragraph-commentaries-section {
                margin-top: 20px;
                padding-top: 15px;
                border-top: 2px solid #d4a574;
            }
            .paragraph-commentaries-title {
                font-weight: bold;
                color: #8b4513;
                margin-bottom: 15px;
                font-size: 14pt;
                text-align: center;
                background-color: #faf0e6;
                padding: 8px;
                border-radius: 5px;
            }
            .inline-commentary {
                margin: 15px 0;
                padding: 15px;
                background-color: #fffef7;
                border-right: 4px solid #daa520;
                border-radius: 5px;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
            .inline-commentary-header {
                display: flex;
                align-items: center;
                margin-bottom: 10px;
                font-weight: bold;
                color: #8b4513;
                font-size: 13pt;
            }
            .inline-commentary-number {
                background-color: #daa520;
                color: white;
                padding: 4px 8px;
                border-radius: 50%;
                font-weight: bold;
                margin-left: 10px;
                font-size: 11pt;
                min-width: 20px;
                text-align: center;
            }
            .inline-commentary-number a {
                color: white;
                text-decoration: none;
            }
            .inline-commentary-number a:hover {
                text-decoration: underline;
            }
            .inline-commentary-title {
                flex: 1;
            }
            .inline-commentary-text {
                font-size: 13pt;
                color: #2c3e50;
                line-height: 1.6;
                margin-bottom: 8px;
                font-style: italic;
            }
            .inline-commentary-link {
                color: #8b4513;
                text-decoration: none;
                font-size: 10pt;
                font-weight: bold;
            }
            .inline-commentary-link:hover {
                text-decoration: underline;
                color: #654321;
            }
            
            /* עיצוב הערות סיום (קישורים אינטראקטיביים) */
            .endnote-ref {
                color: #8b4513;
                font-weight: bold;
                text-decoration: none;
                cursor: pointer;
                vertical-align: super;
                font-size: 0.8em;
            }
            .endnote-ref:hover {
                background-color: #fff8dc;
                border-radius: 2px;
                text-decoration: underline;
            }
            .endnote-back {
                color: #8b4513;
                text-decoration: none;
                font-weight: bold;
            }
            .endnote-back:hover {
                text-decoration: underline;
                background-color: #fff8dc;
            }
            
            /* הערות שוליים רגילות (לקישורים) */
            .footnotes-section {
                margin-top: 50px;
                padding-top: 20px;
                border-top: 3px solid #333;
            }
            .footnotes-title {
                font-size: 18pt;
                font-weight: bold;
                color: #333;
                margin-bottom: 20px;
                text-align: center;
            }
            .footnote {
                margin-bottom: 10px;
                font-size: 11pt;
                color: #666;
            }
            .footnote-number {
                font-weight: bold;
                color: #8e44ad;
                margin-left: 5px;
            }
            .footnote-link {
                color: #4a7c59;
                text-decoration: none;
                font-size: 10pt;
            }
            .superscript {
                vertical-align: super;
                font-size: 0.8em;
                color: #8e44ad;
                font-weight: bold;
            }
            .timestamp {
                text-align: center;
                font-size: 10pt;
                color: #888;
                margin-top: 30px;
                border-top: 1px solid #ccc;
                padding-top: 15px;
            }
            @media print {
                body { margin: 1cm; }
                .sefaria-link { color: #000; }
                .endnote-ref { color: #000; }
                .inline-commentary-link { color: #000; }
            }
        </style>
    </head>
    <body>`;

    // כותרת ומידע על המסמך
    html += `
        <div class="main-title">${title}</div>`;

    if (options.includeTimestamp || options.includeLinks) {
        html += `<div class="document-info">`;
        if (options.includeTimestamp) {
            html += `<div><strong>תאריך יצירה:</strong> ${new Date().toLocaleDateString('he-IL')} ${new Date().toLocaleTimeString('he-IL')}</div>`;
        }
        if (options.includeLinks) {
            html += `<div><strong>מקור:</strong> ספריא - www.sefaria.org</div>`;
        }
        html += `</div>`;
    }

    // עיבוד כל פיסקא
    documentData.forEach(paragraph => {
        html += `<div class="paragraph-container">`;

        // כותרת הפיסקא
        if (options.includeParagraphNumbers) {
            html += `
                <div class="paragraph-header">
                    <span class="paragraph-number">${paragraph.paragraphNum}</span>
                    ${paragraph.ref}
                </div>`;
        }

        // הטקסט העברי הראשי
        let paragraphText = paragraph.hebrewText;

        // הוספת קישור לספריא אם נדרש
        if (options.includeLinks) {
            if (options.linkType === 'direct') {
                paragraphText = `<a href="${paragraph.sefariaLink}" class="sefaria-link">${paragraphText}</a>`;
            } else if (options.linkType === 'footnotes') {
                paragraphText += `<span class="superscript">${this.footnoteCounter}</span>`;
                footnotes.push({
                    number: this.footnoteCounter++,
                    text: `קישור לספריא: ${paragraph.sefariaLink}`
                });
            }
        }

        // הוספת מספור פירושים (עם קישורים אינטראקטיביים)
        paragraph.commentaries.forEach(commentary => {
            paragraphText += `<sup><a name="endnote_ref_${this.endnoteCounter}"></a><a href="#endnote_${this.endnoteCounter}" class="endnote-ref">${this.endnoteCounter}</a></sup>`;
            this.endnoteCounter++;
        });

        html += `<div class="paragraph-text">${paragraphText}</div>`;

        // גירסאות נוספות
        if (paragraph.additionalVersions && paragraph.additionalVersions.length > 0) {
            html += `
                <div class="additional-versions-section"> `;
                   
            
            paragraph.additionalVersions.forEach(version => {
                html += `
                    <div class="additional-version">
                        <div class="version-title">${version.title}</div>
                        <div class="version-text">${version.text}</div>
                    </div>`;
            });
            
            html += `</div>`;
        }

        // פירושים מקומיים תחת הפיסקה
        if (paragraph.commentaries && paragraph.commentaries.length > 0) {
            html += `
                <div class="paragraph-commentaries-section">
                    <div class="paragraph-commentaries-title">📖 פירושים והערות</div>`;
            
            let commentaryCounter = this.endnoteCounter - paragraph.commentaries.length;
            paragraph.commentaries.forEach(commentary => {
                html += `
                    <div class="inline-commentary">
                        <div class="inline-commentary-header">
                            <span class="inline-commentary-number">
                                <a name="endnote_${commentaryCounter}"></a>
                                <a href="#endnote_ref_${commentaryCounter}" class="endnote-back">${commentaryCounter}</a>
                            </span>
                            <span class="inline-commentary-title">${commentary.title}</span>
                        </div>
                        <div class="inline-commentary-text">${commentary.text}</div>
                        <a href="${commentary.link}" class="inline-commentary-link" target="_blank">🔗 קישור למקור בספריא</a>
                    </div>`;
                commentaryCounter++;
            });
            
            html += `</div>`;
        }

        html += `</div>`;
    });

    // הערות שוליים (קישורים בלבד)
    if (options.includeFootnotes && footnotes.length > 0) {
        html += `
            <div class="footnotes-section">
                <div class="footnotes-title">הערות שוליים</div>`;
        
        footnotes.forEach(footnote => {
            html += `
                <div class="footnote">
                    <span class="footnote-number">${footnote.number}.</span>
                    <a href="${footnote.text.split(': ')[1]}" class="footnote-link">${footnote.text}</a>
                </div>`;
        });
        
        html += `</div>`;
    }

    // חותמת זמן
    if (options.includeTimestamp) {
        html += `
            <div class="timestamp">
                נוצר באמצעות ניווט ספריא מתקדם ב-${new Date().toLocaleDateString('he-IL')} ${new Date().toLocaleTimeString('he-IL')}
            </div>`;
    }

    html += `
    </body>
    </html>`;

    // הורדת הקובץ
    const blob = new Blob([html], { type: 'application/msword' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    
    let filename = title.replace(/[^\u0590-\u05FF\w\s-]/g, '');
    if (options.includeLinks) {
        filename += '_עם_קישורים';
    }
    if (documentData.some(p => p.commentaries && p.commentaries.length > 0)) {
        filename += '_עם_פירושים';
    }
    filename += '.doc';
    
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}
            updateBreadcrumb() {
                const breadcrumb = document.getElementById('breadcrumb');
                let path = '📍 דף הבית';

                this.currentPath.forEach(item => {
                    if (item.category) {
                        path += ` > ${item.heCategory || item.category}`;
                    } else if (item.title) {
                        path += ` > ${item.heTitle || item.title}`;
                    }
                });

                breadcrumb.textContent = path;
            }

            updateBackButton() {
                document.getElementById('backBtn').disabled = this.currentPath.length === 0;
            }

            // פונקציות עזר
            log(message, data = null, type = 'info') {
                const debugPanel = document.getElementById('debugPanel');
                const timestamp = new Date().toLocaleTimeString();

                let logEntry = `[${timestamp}] ${message}`;
                if (data) {
                    logEntry += '\n' + JSON.stringify(data, null, 2);
                }

                const logDiv = document.createElement('div');
                logDiv.style.color = type === 'error' ? '#ff6b6b' : type === 'success' ? '#51cf66' : '#74c0fc';
                logDiv.style.marginBottom = '5px';
                logDiv.textContent = logEntry;

                debugPanel.appendChild(logDiv);
                debugPanel.scrollTop = debugPanel.scrollHeight;

                console.log(message, data);
            }

            clearDebug() {
                document.getElementById('debugPanel').innerHTML = '<div>📱 Enhanced Debug cleared</div>';
            }

            showError(message) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error';
                errorDiv.textContent = message;
                document.body.appendChild(errorDiv);

                setTimeout(() => {
                    if (errorDiv.parentNode) {
                        errorDiv.parentNode.removeChild(errorDiv);
                    }
                }, 5000);
            }

            showSuccess(message) {
                const successDiv = document.createElement('div');
                successDiv.className = 'success';
                successDiv.textContent = message;
                document.body.appendChild(successDiv);

                setTimeout(() => {
                    if (successDiv.parentNode) {
                        successDiv.parentNode.removeChild(successDiv);
                    }
                }, 5000);
            }
        }

        // התחלת האפליקציה המשופרת
        document.addEventListener('DOMContentLoaded', () => {
            new EnhancedSefariaNavigator();
        });
    </script>
</body>

</html>