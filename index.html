<!DOCTYPE html>
<html dir="rtl" lang="he">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>× ×™×•×•×˜ ×¡×¤×¨×™× </title>
    <link rel="stylesheet" href="styles.css">
       

</head>

<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ›ï¸ × ×™×•×•×˜ ×¡×¤×¨×™× </h1>
            <p>× ×•×•×˜ ×‘×¡×¤×¨×™ ×”×§×•×“×© ×¢× ×§×™×©×•×¨×™× ×•×¤×™×¨×•×©×™× </p>
        </div>

        <!-- ×©×œ×‘ 1: × ×™×•×•×˜ ×œ×§×˜×’×•×¨×™×•×ª -->
        <div id="categoriesStep" class="step">
            <div class="breadcrumb" id="breadcrumb">ğŸ“ ×“×£ ×”×‘×™×ª</div>

            <div class="nav-buttons">
                <button class="btn" id="backBtn" disabled>ğŸ”™ ×—×–×•×¨</button>
                <button class="btn" id="homeBtn">ğŸ  ×“×£ ×”×‘×™×ª</button>
            </div>

            <div id="contentArea">
                <div class="loading">×˜×•×¢×Ÿ ×§×˜×’×•×¨×™×•×ª</div>
            </div>
        </div>

        <!-- ×©×œ×‘ 2: ×‘×—×™×¨×ª section -->
        <div id="sectionStep" class="step hidden">
            <div class="breadcrumb" id="sectionBreadcrumb">ğŸ“ ×‘×—×™×¨×ª ×—×œ×§</div>

            <div class="nav-buttons">
                <button class="btn" id="backToBookFromSectionBtn">ğŸ”™ ×—×–×•×¨ ×œ×¡×¤×¨</button>
                <button class="btn" id="homeFromSectionBtn">ğŸ  ×“×£ ×”×‘×™×ª</button>
            </div>

            <div class="section">
                <h3>ğŸ“– ×¡×¤×¨ × ×‘×—×¨: <span id="selectedBookTitleSection"></span></h3>
                <h3>ğŸ“‘ ×‘×—×¨ ×—×œ×§:</h3>
                <select id="sectionSelect">
                    <option value="">×‘×—×¨ ×—×œ×§...</option>
                </select>
            </div>
        </div>

        <!-- ×©×œ×‘ 3: ×‘×—×™×¨×ª ×¤×¨×§ -->
        <div id="chapterStep" class="step hidden">
            <div class="breadcrumb" id="chapterBreadcrumb">ğŸ“ ×‘×—×™×¨×ª ×¤×¨×§</div>

            <div class="nav-buttons">
                <button class="btn" id="backToSectionBtn">ğŸ”™ ×—×–×•×¨ ×œ×—×œ×§</button>
                <button class="btn" id="backToBookBtn">ğŸ”™ ×—×–×•×¨ ×œ×¡×¤×¨</button>
                <button class="btn" id="homeFromChapterBtn">ğŸ  ×“×£ ×”×‘×™×ª</button>
            </div>

            <div class="section">
                <h3>ğŸ“– × ×‘×—×¨: <span id="selectedBookTitle"></span></h3>
                <h3 id="selectedSectionTitle" class="hidden">ğŸ“‘ ×—×œ×§: <span id="selectedSectionName"></span></h3>
                <h3>ğŸ”¢ ×‘×—×¨ ×¤×¨×§:</h3>
                <select id="chapterSelect">
                    <option value="">×‘×—×¨ ×¤×¨×§...</option>
                </select>
            </div>
        </div>

        <!-- ×©×œ×‘ 4: ×‘×—×™×¨×ª ×¤×™×¡×§××•×ª ×•×’×™×¨×¡××•×ª -->
        <div id="paragraphStep" class="step hidden">
            <div class="breadcrumb" id="paragraphBreadcrumb">ğŸ“ ×‘×—×™×¨×ª ×¤×™×¡×§××•×ª ×•××¤×©×¨×•×™×•×ª</div>

            <div class="nav-buttons">
                <button class="btn" id="backToChapterBtn">ğŸ”™ ×—×–×•×¨ ×œ×¤×¨×§</button>
                <button class="btn" id="homeFromParagraphBtn">ğŸ  ×“×£ ×”×‘×™×ª</button>
            </div>

            <div class="section">
                <h3>ğŸ“„ ×¤×¨×§ × ×‘×—×¨: <span id="selectedChapterTitle"></span></h3>

                <div class="paragraph-selector">
                    <div>
                        <label>×¤×™×¡×§× ×”×ª×—×œ×”:</label>
                        <select id="startParagraph">
                            <option value="">×‘×—×¨ ×”×ª×—×œ×”...</option>
                        </select>
                    </div>
                    <div>
                        <label>×¤×™×¡×§× ×¡×•×£:</label>
                        <select id="endParagraph">
                            <option value="">×‘×—×¨ ×¡×•×£...</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- ××¤×©×¨×•×™×•×ª ×¤×•×¨××˜ ×•×¤×œ×˜ -->
            <div class="output-options">
                <h4>âš™ï¸ ××¤×©×¨×•×™×•×ª ×¤×•×¨××˜:</h4>
                <div class="option-group">
                    <div class="option-item">
                        <label>×”×•×¡×¤×ª ×§×™×©×•×¨×™× ×œ×¡×¤×¨×™×</label>
                        <input type="checkbox" id="includeLinks" >
                    </div>
                    <div class="option-item">
                        <label>×”×¢×¨×•×ª ×©×•×œ×™×™×</label>
                        <input type="checkbox" id="includeFootnotes" checked>
                    </div>
                    <div class="option-item">
                        <label>××¡×¤×•×¨ ×¤×™×¡×§××•×ª</label>
                        <input type="checkbox" id="includeParagraphNumbers" checked>
                    </div>
                    <div class="option-item">
                        <label>×ª××¨×™×š ×•×–××Ÿ</label>
                        <input type="checkbox" id="includeTimestamp" >
                    </div>
                </div>

                <div class="hyperlink-settings">
                    <label>×¡×•×’ ×§×™×©×•×¨×™×:</label>
                    <div class="option-group">
                        <div class="option-item">
                            <label>×§×™×©×•×¨ ×™×©×™×¨ ×œ×¡×¤×¨×™×</label>
                            <input type="radio" name="linkType" value="direct" >
                        </div>
                        <div class="option-item">
                            <label>×§×™×©×•×¨×™× ×‘×”×¢×¨×•×ª ×©×•×œ×™×™×</label>
                            <input type="radio" name="linkType" value="footnotes" checked>
                        </div>
                    </div>
                </div>
            </div>

            <div class="section">
                <h3>ğŸ“š ×’×™×¨×¡××•×ª × ×•×¡×¤×•×ª:</h3>
                <div id="versionsContainer" class="checkbox-group">
                    <div>×‘×—×¨ ×¤×™×¡×§××•×ª ×ª×—×™×œ×”</div>
                </div>
            </div>

            <div class="section">
                <h3>ğŸ“ ××¤×¨×©×™×:</h3>
                <div id="commentariesContainer" class="checkbox-group">
                    <div>×‘×—×¨ ×¤×™×¡×§××•×ª ×ª×—×™×œ×”</div>
                </div>
            </div>

            <button class="generate-btn" id="generateBtn" disabled>ğŸ“„ ×¦×•×¨ ××¡××š </button>
            <div class="loading hidden" id="generateLoading">××™×™×¦×¨ ××¡××š ×¢× ×§×™×©×•×¨×™× ×•×¤×™×¨×•×©×™×</div>
        </div>

        <!-- ×¤×× ×œ ×“×™×‘×•×’ -->
        <div class="section">
            <h3>ğŸ”§ ×“×™×‘×•×’:</h3>
            <button class="btn" id="clearDebugBtn">ğŸ—‘ï¸ × ×§×”</button>
            <div class="debug-panel" id="debugPanel">
                <div>ğŸ“± Enhanced Sefaria Navigator started</div>
            </div>
        </div>
    </div>

    <script>
        class EnhancedSefariaNavigator {
            constructor() {
                this.baseUrl = 'https://www.sefaria.org/api';
                this.sefariaBaseUrl = 'https://www.sefaria.org';
                this.currentPath = [];
                this.currentBook = null;
                this.currentSection = null;
                this.currentChapter = null;
                this.bookData = null;
                this.chapterData = null;
                this.commentaryCache = new Map();
                this.footnoteCounter = 1;
                
                this.init();
            }

            init() {
                this.log('ğŸš€ Starting Enhanced Sefaria Navigator...');
                this.setupEventListeners();
                this.loadCategories();
            }

            setupEventListeners() {
                // × ×™×•×•×˜
                document.getElementById('backBtn').addEventListener('click', () => this.goBack());
                document.getElementById('homeBtn').addEventListener('click', () => this.goHome());
                document.getElementById('backToBookFromSectionBtn').addEventListener('click', () => this.backToBook());
                document.getElementById('homeFromSectionBtn').addEventListener('click', () => this.goHome());
                document.getElementById('backToSectionBtn').addEventListener('click', () => this.backToSection());
                document.getElementById('backToBookBtn').addEventListener('click', () => this.backToBook());
                document.getElementById('homeFromChapterBtn').addEventListener('click', () => this.goHome());
                document.getElementById('backToChapterBtn').addEventListener('click', () => this.backToChapter());
                document.getElementById('homeFromParagraphBtn').addEventListener('click', () => this.goHome());

                // ×‘×—×™×¨×•×ª
                document.getElementById('sectionSelect').addEventListener('change', () => this.onSectionSelect());
                document.getElementById('chapterSelect').addEventListener('change', () => this.onChapterSelect());
                document.getElementById('startParagraph').addEventListener('change', () => this.onParagraphRangeChange());
                document.getElementById('endParagraph').addEventListener('change', () => this.onParagraphRangeChange());

                // ×™×¦×™×¨×ª ××¡××š
                document.getElementById('generateBtn').addEventListener('click', () => this.generateEnhancedDocument());

                // ×“×™×‘×•×’
                document.getElementById('clearDebugBtn').addEventListener('click', () => this.clearDebug());
            }

            // ×›×œ ×”×¤×•× ×§×¦×™×•×ª ×”×§×™×™××•×ª × ×©××¨×•×ª ××•×ª×• ×“×‘×¨ ×¢×“ generateDocument...
            
            goBack() {
                if (this.currentPath.length > 0) {
                    this.currentPath.pop();
                    if (this.currentPath.length === 0) {
                        this.loadCategories();
                    } else {
                        const parent = this.currentPath[this.currentPath.length - 1];
                        this.navigateToCategory(parent);
                        this.currentPath.pop();
                    }
                    this.updateBreadcrumb();
                    this.updateBackButton();
                }
            }

            goHome() {
                this.currentPath = [];
                this.currentBook = null;
                this.currentSection = null;
                this.currentChapter = null;

                document.getElementById('categoriesStep').classList.remove('hidden');
                document.getElementById('sectionStep').classList.add('hidden');
                document.getElementById('chapterStep').classList.add('hidden');
                document.getElementById('paragraphStep').classList.add('hidden');

                this.loadCategories();
                this.updateBreadcrumb();
                this.updateBackButton();

                this.log('ğŸ  ×—×–×¨×” ×œ×“×£ ×”×‘×™×ª');
            }

            backToBook() {
                this.currentSection = null;
                document.getElementById('sectionStep').classList.add('hidden');
                document.getElementById('chapterStep').classList.add('hidden');
                document.getElementById('paragraphStep').classList.add('hidden');
                document.getElementById('categoriesStep').classList.remove('hidden');
                this.log('ğŸ“– ×—×–×¨×” ×œ×‘×—×™×¨×ª ×¡×¤×¨');
            }

            backToSection() {
                document.getElementById('chapterStep').classList.add('hidden');
                document.getElementById('paragraphStep').classList.add('hidden');
                document.getElementById('sectionStep').classList.remove('hidden');
                this.log('ğŸ“‘ ×—×–×¨×” ×œ×‘×—×™×¨×ª ×¡×§×©×Ÿ');
            }

            backToChapter() {
                document.getElementById('paragraphStep').classList.add('hidden');
                document.getElementById('chapterStep').classList.remove('hidden');
                this.log('ğŸ”¢ ×—×–×¨×” ×œ×‘×—×™×¨×ª ×¤×¨×§');
            }

            async loadCategories() {
                try {
                    this.log('ğŸ“š Loading categories...');
                    const response = await fetch(`${this.baseUrl}/index`);
                    const data = await response.json();
                    this.displayCategories(data);
                } catch (error) {
                    this.log(`âŒ Error loading categories: ${error.message}`, 'error');
                    this.showError('×©×’×™××” ×‘×˜×¢×™× ×ª ×”×§×˜×’×•×¨×™×•×ª');
                }
            }

            displayCategories(categories) {
                const contentArea = document.getElementById('contentArea');
                contentArea.innerHTML = '';

                if (!Array.isArray(categories)) {
                    this.log('âŒ Categories is not an array:', categories, 'error');
                    return;
                }

                const grid = document.createElement('div');
                grid.className = 'grid';

                categories.forEach(category => {
                    if (category.category) {
                        const card = this.createCard(
                            category.category,
                            category.heCategory || '',
                            () => this.navigateToCategory(category)
                        );
                        grid.appendChild(card);
                    }
                });

                contentArea.appendChild(grid);
                this.updateBreadcrumb();
            }

            async navigateToCategory(category) {
                try {
                    this.log(`ğŸ” Navigating to category: ${category.category}`);
                    this.currentPath.push(category);

                    if (category.contents) {
                        this.displayContents(category.contents);
                    } else {
                        const response = await fetch(`${this.baseUrl}/index/${encodeURIComponent(category.category)}`);
                        const data = await response.json();
                        this.displayContents(data.contents || []);
                    }

                    this.updateBreadcrumb();
                    this.updateBackButton();
                } catch (error) {
                    this.log(`âŒ Error navigating to category: ${error.message}`, 'error');
                }
            }

            displayContents(contents) {
                const contentArea = document.getElementById('contentArea');
                contentArea.innerHTML = '';

                if (!Array.isArray(contents)) {
                    this.log('âŒ Contents is not an array:', contents, 'error');
                    return;
                }

                const grid = document.createElement('div');
                grid.className = 'grid';

                contents.forEach(item => {
                    if (item.category) {
                        const card = this.createCard(
                            item.category,
                            item.heCategory || '',
                            () => this.navigateToCategory(item)
                        );
                        grid.appendChild(card);
                    } else if (item.title) {
                        const card = this.createCard(
                            item.title,
                            item.heTitle || '',
                            () => this.selectBook(item)
                        );
                        card.classList.add('book-card');
                        grid.appendChild(card);
                    }
                });

                contentArea.appendChild(grid);
            }

            createCard(title, subtitle, onClick) {
                const card = document.createElement('div');
                card.className = 'card';
                card.onclick = onClick;

                const titleEl = document.createElement('div');
                titleEl.className = 'card-title';
                titleEl.textContent = subtitle;

                const subtitleEl = document.createElement('div');
                subtitleEl.className = 'card-subtitle';
                subtitleEl.textContent = title;

                card.appendChild(titleEl);
                card.appendChild(subtitleEl);

                return card;
            }

            async selectBook(book) {
                try {
                    this.log(`ğŸ“– Selected book: ${book.title}`);
                    this.currentBook = book;
                    
                    this.commentaryCache.clear();
                    this.log('ğŸ§¹ Cleared commentary cache');

                    const v2Response = await fetch(`${this.baseUrl}/v2/raw/index/${encodeURIComponent(book.title)}`);
                    this.bookData = await v2Response.json();
                    
                    if (this.bookData.schema && this.bookData.schema.nodes && this.bookData.schema.nodes.length > 0) {
                        this.log(`ğŸ“š Complex book with ${this.bookData.schema.nodes.length} sections`);
                        this.showSectionStep();
                    } else {
                        this.log('ğŸ“– Simple book structure');
                        this.showChapterStep();
                        this.populateChapters();
                    }
                } catch (error) {
                    this.log(`âŒ Error selecting book: ${error.message}`, 'error');
                    this.showError('×©×’×™××” ×‘×˜×¢×™× ×ª ×”×¡×¤×¨');
                }
            }

            showSectionStep() {
                document.getElementById('categoriesStep').classList.add('hidden');
                document.getElementById('sectionStep').classList.remove('hidden');
                document.getElementById('selectedBookTitleSection').textContent = this.currentBook.heTitle || this.currentBook.title;
                this.populateSections();
            }

            populateSections() {
                const sectionSelect = document.getElementById('sectionSelect');
                sectionSelect.innerHTML = '<option value="">×‘×—×¨ ×—×œ×§...</option>';

                if (this.bookData.schema && this.bookData.schema.nodes) {
                    this.bookData.schema.nodes.forEach((section, index) => {
                        const option = document.createElement('option');
                        option.value = section.key || section.title;
                        option.textContent = section.titles[1].text || section.title;
                        option.dataset.index = index;
                        sectionSelect.appendChild(option);
                    });
                    this.log(`ğŸ“‘ Added ${this.bookData.schema.nodes.length} sections`);
                }
            }

            async onSectionSelect() {
                const sectionSelect = document.getElementById('sectionSelect');
                const selectedOption = sectionSelect.options[sectionSelect.selectedIndex];

                if (!selectedOption.value) return;

                this.currentSection = {
                    key: selectedOption.value,
                    index: parseInt(selectedOption.dataset.index),
                    title: selectedOption.textContent,
                    data: this.bookData.schema.nodes[selectedOption.dataset.index],
                };

                this.log(`ğŸ“‘ Selected section: ${this.currentSection.title}`, this.currentSection);
                this.showChapterStep();
                this.populateChaptersForSection();
            }

            populateChaptersForSection() {
                const chapterSelect = document.getElementById('chapterSelect');
                chapterSelect.innerHTML = '<option value="">×‘×—×¨ ×¤×¨×§...</option>';

                const sectionData = this.currentSection.data;

                if (sectionData.index_offsets_by_depth && sectionData.index_offsets_by_depth["2"]) {
                    const offsets = sectionData.index_offsets_by_depth["2"];
                    const numChapters = offsets.length;

                    this.log(`ğŸ“– Section has ${numChapters} chapters`);

                    for (let i = 1; i <= numChapters; i++) {
                        const option = document.createElement('option');
                        option.value = i;
                        option.textContent = `×¤×¨×§ ${i}`;
                        chapterSelect.appendChild(option);
                    }

                    document.getElementById('selectedSectionTitle').classList.remove('hidden');
                    document.getElementById('selectedSectionName').textContent = this.currentSection.title;
                } else {
                    this.log('âŒ No chapter information found for section', 'error');
                }
            }

            showChapterStep() {
                document.getElementById('categoriesStep').classList.add('hidden');
                document.getElementById('sectionStep').classList.add('hidden');
                document.getElementById('chapterStep').classList.remove('hidden');
                document.getElementById('selectedBookTitle').textContent = this.currentBook.heTitle || this.currentBook.title;

                if (this.currentSection) {
                    document.getElementById('selectedSectionTitle').classList.remove('hidden');
                    document.getElementById('selectedSectionName').textContent = this.currentSection.title;
                    document.getElementById('backToSectionBtn').style.display = 'inline-block';
                } else {
                    document.getElementById('selectedSectionTitle').classList.add('hidden');
                    document.getElementById('backToSectionBtn').style.display = 'none';
                }
            }

            populateChapters() {
                const chapterSelect = document.getElementById('chapterSelect');
                chapterSelect.innerHTML = '<option value="">×‘×—×¨ ×¤×¨×§...</option>';

                let chapterCount = 0;
                
                this.log('ğŸ“Š Book structure:', this.bookData);
                
                if (this.bookData.schema && this.bookData.schema.lengths && this.bookData.schema.lengths.length > 0) {
                    chapterCount = this.bookData.schema.lengths[0];
                    this.log(`ğŸ“š Using schema.lengths: ${chapterCount} chapters`);
                } else if (this.bookData.schema && this.bookData.schema.content_counts && this.bookData.schema.content_counts.length > 0) {
                    chapterCount = this.bookData.schema.content_counts.length;
                    this.log(`ğŸ“š Using schema.content_counts: ${chapterCount} chapters`);
                } else if (this.bookData.lengths && this.bookData.lengths.length > 0) {
                    chapterCount = this.bookData.lengths[0];
                    this.log(`ğŸ“š Using book.lengths: ${chapterCount} chapters`);
                } else if (this.bookData.alt_structs && this.bookData.alt_structs.Parasha && this.bookData.alt_structs.Parasha.nodes) {
                    chapterCount = this.estimateChaptersFromParashiot(this.bookData.alt_structs.Parasha.nodes);
                    this.log(`ğŸ“š Estimated from Parashot: ${chapterCount} chapters`);
                } else {
                    chapterCount = 50;
                    this.log(`ğŸ“š Using default chapter count: ${chapterCount}`);
                }
                
                for (let i = 1; i <= chapterCount; i++) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = `×¤×¨×§ ${i}`;
                    chapterSelect.appendChild(option);
                }
                
                this.log(`ğŸ“š Added ${chapterCount} chapters to select menu`);
            }

            estimateChaptersFromParashiot(parashiot) {
                try {
                    let maxChapter = 0;
                    
                    for (const parasha of parashiot) {
                        if (parasha.wholeRef) {
                            const match = parasha.wholeRef.match(/(\d+):(\d+)-(\d+):(\d+)/);
                            if (match && match[3]) {
                                const endChapter = parseInt(match[3]);
                                if (endChapter > maxChapter) {
                                    maxChapter = endChapter;
                                }
                            }
                        }
                    }
                    
                    return maxChapter || 50;
                } catch (error) {
                    this.log(`âŒ Error estimating chapters from parashiot: ${error.message}`, 'error');
                    return 50;
                }
            }

            async onChapterSelect() {
                const chapterNum = document.getElementById('chapterSelect').value;
                if (!chapterNum) return;

                try {
                    this.log(`ğŸ“„ Loading chapter ${chapterNum}`);
                    this.currentChapter = chapterNum;

                    let chapterRef;
                    if (this.currentSection) {
                        chapterRef = `${this.currentBook.title}, ${this.currentSection.key} ${chapterNum}`;
                    } else {
                        chapterRef = `${this.currentBook.title} ${chapterNum}`;
                    }

                    this.log(`ğŸ”— Chapter reference: ${chapterRef}`);

                    const chapterInfoResponse = await fetch(`${this.baseUrl}/texts/${encodeURIComponent(chapterRef)}`);
                    const chapterInfo = await chapterInfoResponse.json();

                    this.chapterInfo = {
                        heTitle: chapterInfo.heTitle || '',
                        heSectionRef: chapterInfo.heSectionRef || '',
                        bookTitle: chapterInfo.book || this.currentBook.title,
                        heBook: chapterInfo.heBook || '',
                        offset: chapterInfo.index_offsets_by_depth?.["2"]?.[0] || 0
                    };

                    const isSimpleBook = !this.currentSection;
                    if (isSimpleBook && chapterInfo.he && Array.isArray(chapterInfo.he)) {
                        this.chapterData = chapterInfo;
                        this.log('ğŸ“š Direct use of chapter data for simple book');
                    } else {
                        await this.loadParagraphByParagraph(chapterRef);
                    }

                    this.showParagraphStep();
                    this.populateParagraphs();
                } catch (error) {
                    this.log(`âŒ Error loading chapter: ${error.message}`, 'error');
                    this.showError('×©×’×™××” ×‘×˜×¢×™× ×ª ×”×¤×¨×§');
                }
            }

            async loadParagraphByParagraph(chapterRef) {
                this.log(`ğŸ“ Loading paragraphs for: ${chapterRef}`);
                
                const isSimpleBook = !this.currentSection;
                
                if (isSimpleBook) {
                    try {
                        this.log(`ğŸ“š Loading entire chapter at once for simple book: ${chapterRef}`);
                        const response = await fetch(`${this.baseUrl}/texts/${encodeURIComponent(chapterRef)}`);
                        
                        if (response.ok) {
                            const chapterData = await response.json();
                            
                            if (chapterData.he && Array.isArray(chapterData.he)) {
                                this.chapterData = chapterData;
                                this.log(`âœ… Successfully loaded ${chapterData.he.length} paragraphs at once`);
                                return;
                            } else {
                                this.log(`âš ï¸ Unexpected format for chapter data`);
                            }
                        } else {
                            this.log(`âŒ Failed to load chapter: ${response.status}`);
                        }
                    } catch (error) {
                        this.log(`âŒ Error loading full chapter: ${error.message}`);
                    }
                }

                const chapterNum = parseInt(this.currentChapter);
                let expectedParagraphs = this.getExpectedParagraphCount(chapterNum);
                
                if (expectedParagraphs) {
                    this.log(`ğŸ“Š Expected ${expectedParagraphs} paragraphs for chapter ${chapterNum}`);
                    await this.loadExactParagraphCount(chapterRef, expectedParagraphs);
                } else {
                    this.log('ğŸ“Š No expected count, using discovery method');
                    await this.loadParagraphsDiscovery(chapterRef);
                }
            }

            getExpectedParagraphCount(chapterNum) {
                let counts = null;

                if (this.currentSection && this.currentSection.data.content_counts) {
                    counts = this.currentSection.data.content_counts;
                } else if (this.bookData.schema && this.bookData.schema.content_counts) {
                    counts = this.bookData.schema.content_counts;
                } else if (this.bookData.schema && this.bookData.schema.lengths) {
                    counts = this.bookData.schema.lengths;
                } else if (this.bookData.lengths && this.bookData.lengths.length > 1) {
                    counts = this.bookData.lengths[1];
                }

                if (counts && Array.isArray(counts) && counts[chapterNum - 1]) {
                    return counts[chapterNum - 1];
                }

                return null;
            }

            async loadExactParagraphCount(chapterRef, expectedCount) {
                this.log(`ğŸ“š Loading ${expectedCount} paragraphs exactly`);

                this.chapterData = { he: [] };

                for (let paragraphNum = 1; paragraphNum <= expectedCount; paragraphNum++) {
                    const paragraphRef = `${chapterRef}:${paragraphNum}`;

                    try {
                        this.log(`ğŸ“„ Loading paragraph ${paragraphNum}/${expectedCount}: ${paragraphRef}`);

                        const response = await fetch(`${this.baseUrl}/texts/${encodeURIComponent(paragraphRef)}`);

                        if (response.ok) {
                            const paragraphData = await response.json();

                            if (paragraphData.he) {
                                const paragraphText = Array.isArray(paragraphData.he) ?
                                    paragraphData.he[0] || paragraphData.he.join(' ') : paragraphData.he;

                                if (paragraphText && paragraphText.trim()) {
                                    this.chapterData.he.push(paragraphText);
                                    this.log(`âœ… Loaded paragraph ${paragraphNum}: ${paragraphText.substring(0, 50)}...`);
                                } else {
                                    this.chapterData.he.push('');
                                    this.log(`âš ï¸ Empty paragraph ${paragraphNum}`);
                                }
                            } else {
                                this.chapterData.he.push('');
                                this.log(`âš ï¸ No Hebrew text for paragraph ${paragraphNum}`);
                            }
                        } else {
                            this.chapterData.he.push('');
                            this.log(`âŒ Failed to load paragraph ${paragraphNum}: ${response.status}`);
                        }

                        await new Promise(resolve => setTimeout(resolve, 100));

                    } catch (error) {
                        this.log(`âŒ Error loading paragraph ${paragraphNum}: ${error.message}`);
                        this.chapterData.he.push('');
                    }
                }

                while (this.chapterData.he.length > 0 && !this.chapterData.he[this.chapterData.he.length - 1].trim()) {
                    this.chapterData.he.pop();
                }

                this.log(`ğŸ“Š Loaded ${this.chapterData.he.length} paragraphs out of ${expectedCount} expected`);
            }

            async loadParagraphsDiscovery(chapterRef) {
                this.log(`ğŸ” Discovering paragraphs for: ${chapterRef}`);

                try {
                    const fullChapterResponse = await fetch(`${this.baseUrl}/texts/${encodeURIComponent(chapterRef)}`);

                    if (fullChapterResponse.ok) {
                        const fullChapterData = await fullChapterResponse.json();

                        if (fullChapterData.he && Array.isArray(fullChapterData.he)) {
                            this.chapterData = fullChapterData;
                            this.log(`âœ… Loaded ${fullChapterData.he.length} paragraphs from full chapter`);
                            return;
                        }
                    }
                } catch (error) {
                    this.log(`âŒ Error loading full chapter: ${error.message}`);
                }

                await this.discoverExistingParagraphs(chapterRef);
            }

            async discoverExistingParagraphs(chapterRef) {
                this.log(`ğŸ” Discovering existing paragraphs for: ${chapterRef}`);

                this.chapterData = { he: [] };
                const maxAttempts = 200;
                const maxFailures = 10;
                let consecutiveFailures = 0;

                for (let paragraphNum = 1; paragraphNum <= maxAttempts; paragraphNum++) {
                    const paragraphRef = `${chapterRef}:${paragraphNum}`;

                    try {
                        this.log(`ğŸ” Trying paragraph ${paragraphNum}`);

                        const response = await fetch(`${this.baseUrl}/texts/${encodeURIComponent(paragraphRef)}`);

                        if (response.ok) {
                            const paragraphData = await response.json();

                            if (paragraphData.he && paragraphData.he.length > 0) {
                                const paragraphText = Array.isArray(paragraphData.he) ?
                                    paragraphData.he[0] : paragraphData.he;

                                if (paragraphText && paragraphText.trim()) {
                                    this.chapterData.he.push(paragraphText);
                                    this.log(`âœ… Found paragraph ${paragraphNum}`);
                                    consecutiveFailures = 0;
                                } else {
                                    consecutiveFailures++;
                                }
                            } else {
                                consecutiveFailures++;
                            }
                        } else if (response.status === 404) {
                            consecutiveFailures++;
                            this.log(`â­ï¸ Paragraph ${paragraphNum} not found (404)`);
                        } else {
                            consecutiveFailures++;
                            this.log(`âŒ Error ${response.status} for paragraph ${paragraphNum}`);
                        }

                        if (consecutiveFailures >= maxFailures) {
                            this.log(`ğŸ›‘ Stopping after ${maxFailures} consecutive failures`);
                            break;
                        }

                        await new Promise(resolve => setTimeout(resolve, 50));

                    } catch (error) {
                        this.log(`âŒ Error fetching paragraph ${paragraphNum}: ${error.message}`);
                        consecutiveFailures++;

                        if (consecutiveFailures >= maxFailures) {
                            break;
                        }
                    }
                }

                this.log(`ğŸ“Š Discovery complete: ${this.chapterData.he.length} paragraphs found`);

                if (this.chapterData.he.length === 0) {
                    this.log('âš ï¸ No paragraphs found, trying final fallback');
                    await this.loadChapterFallback(chapterRef);
                }
            }

            async loadChapterFallback(chapterRef) {
                try {
                    const response = await fetch(`${this.baseUrl}/texts/${encodeURIComponent(chapterRef)}`);
                    const data = await response.json();

                    if (data.he && Array.isArray(data.he)) {
                        this.chapterData = data;
                        this.log(`ğŸ“š Fallback: loaded ${data.he.length} paragraphs from full chapter`);
                    } else if (data.he) {
                        this.chapterData = { he: [data.he] };
                        this.log('ğŸ“š Fallback: loaded single paragraph');
                    }
                } catch (error) {
                    this.log(`âŒ Fallback also failed: ${error.message}`, 'error');
                }
            }

            showParagraphStep() {
                document.getElementById('chapterStep').classList.add('hidden');
                document.getElementById('paragraphStep').classList.remove('hidden');

                let title = `${this.currentBook.heTitle || this.currentBook.title}`;
                if (this.currentSection) {
                    title += `, ${this.currentSection.title}`;
                }
                title += ` ×¤×¨×§ ${this.currentChapter}`;

                document.getElementById('selectedChapterTitle').textContent = title;
            }

            async onParagraphRangeChange() {
                const start = document.getElementById('startParagraph').value;
                const end = document.getElementById('endParagraph').value;

                if (start && end) {
                    this.log(`ğŸ“ Paragraph range selected: ${start} to ${end}`);

                    await this.loadVersions();
                    await this.loadCommentaries();

                    document.getElementById('generateBtn').disabled = false;
                } else {
                    document.getElementById('generateBtn').disabled = true;
                }
            }

            async loadVersions() {
                try {
                    this.log('ğŸ“š Loading versions...');
                    const response = await fetch(`${this.baseUrl}/texts/versions/${encodeURIComponent(this.currentBook.title)}`);
                    const versions = await response.json();

                    const container = document.getElementById('versionsContainer');
                    container.innerHTML = '';

                    if (Array.isArray(versions)) {
                        versions.forEach(version => {
                            if (version.languageFamilyName !== 'hebrew' || !version.isPrimary) {
                                const label = document.createElement('label');
                                const checkbox = document.createElement('input');
                                checkbox.type = 'checkbox';
                                checkbox.value = version.versionTitle;
                                checkbox.dataset.language = version.languageFamilyName;
                                checkbox.dataset.title = version.versionTitle;

                                label.appendChild(checkbox);
                                label.appendChild(document.createTextNode(`${version.versionTitle} (${version.languageFamilyName})`));
                                container.appendChild(label);
                            }
                        });
                    }
                } catch (error) {
                    this.log(`âŒ Error loading versions: ${error.message}`, 'error');
                }
            }

            populateParagraphs() {
                const startSelect = document.getElementById('startParagraph');
                const endSelect = document.getElementById('endParagraph');
                
                startSelect.innerHTML = '<option value="">×‘×—×¨ ×”×ª×—×œ×”...</option>';
                endSelect.innerHTML = '<option value="">×‘×—×¨ ×¡×•×£...</option>';

                if (this.chapterData.he && Array.isArray(this.chapterData.he)) {
                    const numParagraphs = this.chapterData.he.length;
                    this.log(`ğŸ“ Chapter has ${numParagraphs} paragraphs`);

                    const paraLabel = this.currentSection ? '×¤×™×¡×§×' : '×¤×¡×•×§';
                    
                    let offset = 0;
                    
                    if (this.chapterInfo && this.chapterInfo.offset !== undefined) {
                        offset = this.chapterInfo.offset;
                        this.log(`ğŸ“Š Using API offset: ${offset}`);
                    } else {
                        this.log(`ğŸ“Š No offset available, using 0`);
                    }

                    for (let i = 1; i <= numParagraphs; i++) {
                        const displayNumber = i + offset;
                        
                        const startOption = document.createElement('option');
                        startOption.value = displayNumber;
                        startOption.textContent = `${paraLabel} ${displayNumber}`;
                        startSelect.appendChild(startOption);

                        const endOption = document.createElement('option');
                        endOption.value = displayNumber;
                        endOption.textContent = `${paraLabel} ${displayNumber}`;
                        endSelect.appendChild(endOption);
                    }
                    
                    this.log('ğŸ”§ Re-ensuring event listeners for paragraph selects');
                    startSelect.removeEventListener('change', this.onParagraphRangeChange.bind(this));
                    endSelect.removeEventListener('change', this.onParagraphRangeChange.bind(this));
                    startSelect.addEventListener('change', this.onParagraphRangeChange.bind(this));
                    endSelect.addEventListener('change', this.onParagraphRangeChange.bind(this));
                    
                } else {
                    this.log('âŒ No paragraph data found in chapter', 'error');
                    
                    for (let i = 1; i <= 10; i++) {
                        const startOption = document.createElement('option');
                        startOption.value = i;
                        startOption.textContent = `×¤×¡×•×§ ${i}`;
                        startSelect.appendChild(startOption);

                        const endOption = document.createElement('option');
                        endOption.value = i;
                        endOption.textContent = `×¤×¡×•×§ ${i}`;
                        endSelect.appendChild(endOption);
                    }
                }
            }

            async loadCommentaries() {
                try {
                    this.log('ğŸ“ Loading commentaries...');
                    const start = document.getElementById('startParagraph').value;

                    if (!start) {
                        document.getElementById('commentariesContainer').innerHTML = '<div>×‘×—×¨ ×¤×™×¡×§××•×ª ×ª×—×™×œ×”</div>';
                        return;
                    }

                    let sampleRef;
                    if (this.currentSection) {
                        sampleRef = `${this.currentBook.title}, ${this.currentSection.key} ${this.currentChapter}:${start}`;
                    } else {
                        sampleRef = `${this.currentBook.title} ${this.currentChapter}:${start}`;
                    }

                    this.log(`ğŸ”— Sample commentary reference: ${sampleRef}`);

                    const commentaries = await this.discoverCommentaries(sampleRef);

                    const container = document.getElementById('commentariesContainer');
                    container.innerHTML = '';

                    if (commentaries.size > 0) {
                        commentaries.forEach(title => {
                            const label = document.createElement('label');
                            const checkbox = document.createElement('input');
                            checkbox.type = 'checkbox';
                            checkbox.value = title;

                            label.appendChild(checkbox);
                            label.appendChild(document.createTextNode(title));
                            container.appendChild(label);
                        });

                        this.log(`âœ… Found ${commentaries.size} commentaries`);
                    } else {
                        container.innerHTML = '<div>×œ× × ××¦××• ××¤×¨×©×™× ×–××™× ×™×</div>';
                        this.log('âŒ No commentaries found');
                    }
                } catch (error) {
                    this.log(`âŒ Error loading commentaries: ${error.message}`, 'error');
                    document.getElementById('commentariesContainer').innerHTML = '<div>×©×’×™××” ×‘×˜×¢×™× ×ª ××¤×¨×©×™×</div>';
                }
            }

            async discoverCommentaries(ref) {
                const commentaries = new Set();

                try {
                    const response = await fetch(`${this.baseUrl}/links/${encodeURIComponent(ref)}`);

                    if (response.ok) {
                        const links = await response.json();

                        if (Array.isArray(links)) {
                            links.forEach(link => {
                                if (link.category === 'Commentary' && link.collectiveTitle) {
                                    const title = link.collectiveTitle.he || link.collectiveTitle.en;
                                    if (title) {
                                        commentaries.add(title);
                                        this.log(`ğŸ“ Found commentary: ${title}`);
                                    }
                                }
                            });
                        }
                    }
                } catch (error) {
                    this.log(`âŒ Error fetching links: ${error.message}`);
                }

                if (commentaries.size === 0) {
                    this.log('ğŸ” No links found, trying known commentaries');
                }

                return commentaries;
            }

            // ×”×¤×•× ×§×¦×™×” ×”××©×•×¤×¨×ª ×œ×™×¦×™×¨×ª ××¡××š ×¢× ×§×™×©×•×¨×™×
            async generateEnhancedDocument() {
                try {
                    this.log('ğŸ“„ Generating enhanced document...');
                    document.getElementById('generateBtn').disabled = true;
                    document.getElementById('generateLoading').classList.remove('hidden');

                    const start = parseInt(document.getElementById('startParagraph').value);
                    const end = parseInt(document.getElementById('endParagraph').value);

                    // ××™×¡×•×£ ××¤×©×¨×•×™×•×ª ×¤×•×¨××˜
                    const includeLinks = document.getElementById('includeLinks').unchecked;
                    const includeFootnotes = document.getElementById('includeFootnotes').checked;
                    const includeParagraphNumbers = document.getElementById('includeParagraphNumbers').checked;
                    const includeTimestamp = document.getElementById('includeTimestamp').unchecked;
                    const linkType = document.querySelector('input[name="linkType"]:checked').value;

                    // ××™×¡×•×£ ×”×’×™×¨×¡××•×ª ×”× ×‘×—×¨×•×ª
                    const selectedVersions = Array.from(document.querySelectorAll('#versionsContainer input[type="checkbox"]:checked'))
                        .map(cb => ({
                            title: cb.dataset.title,
                            language: cb.dataset.language
                        }))
                        .filter(v => v.title && v.language);

                    // ××™×¡×•×£ ×”××¤×¨×©×™× ×”× ×‘×—×¨×™×
                    const selectedCommentaries = Array.from(document.querySelectorAll('#commentariesContainer input:checked'))
                        .map(cb => cb.value);

                    this.log(`ğŸ“Š Selected range: ${start} to ${end}`);
                    this.log(`ğŸ“š Selected versions:`, selectedVersions);
                    this.log(`ğŸ“ Selected commentaries: ${selectedCommentaries.join(', ') || 'none'}`);

                    // ×©×œ×•×£ ××ª ×›×œ ×”×¤×™×¡×§××•×ª ×‘×˜×•×•×—
                    const documentData = await this.fetchDocumentData(start, end, selectedVersions, selectedCommentaries);

                    // ×™×¦×•×¨ ×§×•×‘×¥ Word ××©×•×¤×¨
                    this.createEnhancedWordDocument(documentData, {
                        includeLinks,
                        includeFootnotes,
                        includeParagraphNumbers,
                        includeTimestamp,
                        linkType
                    });

                    this.log('âœ… Enhanced document generated successfully!', 'success');
                    this.showSuccess('×”××¡××š ×”××ª×§×“× × ×•×¦×¨ ×‘×”×¦×œ×—×” ×¢× ×§×™×©×•×¨×™× ×•×¤×™×¨×•×©×™×!');

                } catch (error) {
                    this.log(`âŒ Error generating enhanced document: ${error.message}`, 'error');
                    this.showError('×©×’×™××” ×‘×™×¦×™×¨×ª ×”××¡××š ×”××ª×§×“×');
                } finally {
                    document.getElementById('generateBtn').disabled = false;
                    document.getElementById('generateLoading').classList.add('hidden');
                }
            }

            async fetchDocumentData(startParagraph, endParagraph, selectedVersions, selectedCommentaries) {
                const documentData = [];

                this.log(`ğŸ“š Processing paragraphs ${startParagraph} to ${endParagraph}`);

                for (let index = startParagraph; index <= endParagraph; index++) {
                    this.log(`ğŸ“„ Processing paragraph ${index}`);

                    const offset = this.chapterInfo.offset || 0;
                    const arrayIndex = index - offset - 1;
                    
                    this.log(`ğŸ“Š Array index for paragraph ${index}: ${arrayIndex} (offset: ${offset})`);
                    
                    if (arrayIndex < 0 || arrayIndex >= this.chapterData.he.length) {
                        this.log(`âš ï¸ Invalid array index ${arrayIndex} for paragraph ${index}`);
                        continue;
                    }

                    const hebrewText = this.chapterData.he[arrayIndex];
                    
                    let paragraphRef;
                    if (this.currentSection) {
                        paragraphRef = `${this.currentBook.title}, ${this.currentSection.key} ${this.currentChapter}:${index}`;
                    } else {
                        paragraphRef = `${this.currentBook.title} ${this.currentChapter}:${index}`;
                    }
                    
                    this.log(`ğŸ”— Paragraph reference: ${paragraphRef}`);
                    
                    try {
                        const cleanText = hebrewText.trim();

                        if (!cleanText || cleanText.replace(/<[^>]*>/g, '').trim() === '') {
                            this.log(`âš ï¸ Empty text for paragraph ${index}`);
                            continue;
                        }

                        // ×©×œ×•×£ ××¤×¨×©×™× ×œ×¤×™×¡×§× ×–×•
                        const commentaries = await this.fetchCommentariesForParagraph(paragraphRef, selectedCommentaries);

                        // ×©×œ×•×£ ×’×™×¨×¡××•×ª × ×•×¡×¤×•×ª
                        const additionalVersions = await this.fetchAdditionalVersionsEfficient(paragraphRef, selectedVersions, arrayIndex);

                        // ×™×¦×™×¨×ª ×§×™×©×•×¨ ×œ×¡×¤×¨×™×
                        const sefariaLink = this.createSefariaLink(paragraphRef);

                        documentData.push({
                            paragraphNum: index,
                            ref: paragraphRef,
                            hebrewText: cleanText,
                            additionalVersions,
                            commentaries,
                            sefariaLink
                        });

                        this.log(`âœ… Added paragraph ${index} with ${commentaries.length} commentaries and link: ${sefariaLink}`);

                    } catch (error) {
                        this.log(`âŒ Error processing paragraph ${index}: ${error.message}`, 'error');
                    }

                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                this.log(`ğŸ‰ Document data ready: ${documentData.length} paragraphs`);
                return documentData;
            }

            createSefariaLink(ref) {
                // ×™×¦×™×¨×ª ×§×™×©×•×¨ ×™×©×™×¨ ×œ×¡×¤×¨×™×
                const encodedRef = encodeURIComponent(ref.replace(/,/g, ''));
                return `${this.sefariaBaseUrl}/${encodedRef}`;
            }

            async fetchCommentariesForParagraph(ref, selectedCommentaries) {
                if (selectedCommentaries.length === 0) return [];

                try {
                    this.log(`ğŸ“ Fetching commentaries for: ${ref}`);

                    const response = await fetch(`${this.baseUrl}/links/${encodeURIComponent(ref)}`);
                    const links = await response.json();

                    const commentaries = [];

                    if (Array.isArray(links)) {
                        for (const link of links) {
                            if (link.category === 'Commentary' && link.collectiveTitle) {
                                const commentaryTitle = link.collectiveTitle.he || link.collectiveTitle.en;

                                if (selectedCommentaries.includes(commentaryTitle)) {
                                    this.log(`ğŸ” Processing commentary: ${commentaryTitle} -> ${link.sourceRef}`);

                                    const commentaryText = await this.fetchCommentaryTextSmart(link.sourceRef, ref);
                                    if (commentaryText) {
                                        commentaries.push({
                                            title: commentaryTitle,
                                            text: commentaryText,
                                            ref: link.sourceRef,
                                            link: this.createSefariaLink(link.sourceRef)
                                        });
                                        this.log(`âœ… Added commentary: ${commentaryTitle} (${commentaryText.length} chars)`);
                                    }
                                }
                            }
                        }
                    }

                    return commentaries;
                } catch (error) {
                    this.log(`âŒ Error fetching commentaries for ${ref}: ${error.message}`, 'error');
                    return [];
                }
            }

            async fetchCommentaryTextSmart(commentaryRef, originalRef) {
                try {
                    this.log(`ğŸ“– Fetching commentary smartly: ${commentaryRef}`);

                    const { baseRef, paragraphNum } = this.parseCommentaryRef(commentaryRef, originalRef);

                    this.log(`ğŸ” Parsed: baseRef=${baseRef}, paragraphNum=${paragraphNum}`);

                    const response = await fetch(`${this.baseUrl}/texts/${encodeURIComponent(baseRef)}`);
                    const data = await response.json();

                    this.log(`ğŸ“Š Commentary data for ${baseRef}:`, data);

                    let text = '';

                    if (data.he && Array.isArray(data.he) && paragraphNum !== null) {
                        const paragraphIndex = paragraphNum - 1;
                        if (paragraphIndex >= 0 && paragraphIndex < data.he.length) {
                            text = data.he[paragraphIndex];
                            this.log(`âœ… Found specific paragraph ${paragraphNum}: ${text.substring(0, 100)}...`);
                        } else {
                            this.log(`âŒ Paragraph ${paragraphNum} not found in array of ${data.he.length} items`);
                        }
                    } else if (data.he) {
                        if (Array.isArray(data.he)) {
                            text = data.he.join(' ');
                        } else {
                            text = data.he;
                        }
                        this.log(`ğŸ“„ Using full commentary text (${text.length} chars)`);
                    } else if (data.text) {
                        if (Array.isArray(data.text)) {
                            text = data.text.join(' ');
                        } else {
                            text = data.text;
                        }
                    }

                    if (text) {
                        text = text.replace(/<[^>]*>/g, '').trim();
                    }

                    this.log(`ğŸ“ Final commentary text (${text.length} chars): ${text.substring(0, 100)}...`);
                    return text;

                } catch (error) {
                    this.log(`âŒ Error fetching commentary text: ${error.message}`, 'error');
                    return '';
                }
            }

            parseCommentaryRef(commentaryRef, originalRef) {
                try {
                    const parts = commentaryRef.split(':');

                    if (parts.length >= 3) {
                        const paragraphNum = parseInt(parts[parts.length - 1]);
                        const baseRef = parts.slice(0, -1).join(':');

                        if (!isNaN(paragraphNum)) {
                            return { baseRef, paragraphNum };
                        }
                    }

                    return { baseRef: commentaryRef, paragraphNum: null };

                } catch (error) {
                    this.log(`âŒ Error parsing commentary ref: ${error.message}`);
                    return { baseRef: commentaryRef, paragraphNum: null };
                }
            }

            async fetchAdditionalVersionsEfficient(ref, selectedVersions, arrayIndex) {
                if (!selectedVersions || selectedVersions.length === 0) {
                    return [];
                }

                this.log(`ğŸ“š Fetching additional versions for: ${ref}`);
                const versions = [];

                for (const version of selectedVersions) {
                    try {
                        if (!version.title || !version.language) {
                            this.log(`âš ï¸ Skipping invalid version:`, version);
                            continue;
                        }
                        
                        this.log(`ğŸ” Fetching version: ${version.title} (${version.language})`);
                        
                        const cacheKey = `${this.currentChapter}_${version.title}`;
                        
                        let versionChapterData = this.commentaryCache.get(cacheKey);
                        
                        if (!versionChapterData) {
                            const chapterRef = ref.split(':')[0];
                            const encodedRef = encodeURIComponent(chapterRef);
                            const versionParam = encodeURIComponent(`${version.language}|${version.title}`);
                            const url = `${this.baseUrl}/v3/texts/${encodedRef}?version=${versionParam}`;
                            
                            this.log(`ğŸŒ Version URL for whole chapter: ${url}`);
                            
                            const response = await fetch(url);
                            
                            if (response.ok) {
                                versionChapterData = await response.json();
                                this.log(`ğŸ“Š Version chapter data for ${version.title}:`, versionChapterData);
                                
                                this.commentaryCache.set(cacheKey, versionChapterData);
                            } else {
                                this.log(`âŒ Failed to fetch version ${version.title}: ${response.status}`);
                                continue;
                            }
                        } else {
                            this.log(`ğŸ“‹ Using cached chapter data for version: ${version.title}`);
                        }
                        
                        let versionText = '';
                        if (versionChapterData.versions && versionChapterData.versions[0] && versionChapterData.versions[0].text) {
                            versionText = versionChapterData.versions[0].text[arrayIndex];
                            this.log(`ğŸ“„ Found text for ${version.title}`);
                        }
                        
                        if (!versionText) {
                            this.log(`âš ï¸ No text found for version ${version.title} at index ${arrayIndex}`);
                            continue;
                        }
                        
                        if (versionText && versionText.trim()) {
                            versionText = versionText.replace(/<[^>]*>/g, '').trim();
                            
                            versions.push({
                                title: version.title,
                                heTitle: versionChapterData.versions[0].versionTitleInHebrew || '',
                                language: version.language,
                                text: versionText,
                                link: this.createSefariaLink(ref) + `?v${version.language}=${encodeURIComponent(version.title)}`
                            });
                            
                            this.log(`âœ… Added version: ${version.title} (${versionText.length} chars)`);
                        } else {
                            this.log(`âš ï¸ No text found for version ${version.title} at index ${arrayIndex}`);
                        }
                        
                    } catch (error) {
                        this.log(`âŒ Error fetching version ${version.title}: ${error.message}`, 'error');
                    }
                }

                this.log(`ğŸ“š Fetched ${versions.length} additional versions`);
                return versions;
            }

 // ×”×—×œ×¤×ª ×”×¤×•× ×§×¦×™×” createEnhancedWordDocument
createEnhancedWordDocument(documentData, options) {
    this.footnoteCounter = 1;
    this.endnoteCounter = 1;
    let footnotes = [];
    
    // ×™×¦×™×¨×ª ×›×•×ª×¨×ª ×”××¡××š
    let title = `${this.currentBook.heTitle || this.currentBook.title}`;
    if (this.currentSection) {
        title += `, ${this.currentSection.title}`;
    }
    title += ` ×¤×¨×§ ${this.currentChapter}`;
    
    if (documentData.length > 0) {
        const firstParagraph = documentData[0].paragraphNum;
        const lastParagraph = documentData[documentData.length - 1].paragraphNum;
        if (firstParagraph === lastParagraph) {
            title += ` ×¤×™×¡×§× ${firstParagraph}`;
        } else {
            title += ` ×¤×™×¡×§××•×ª ${firstParagraph}-${lastParagraph}`;
        }
    }

    let html = `
    <!DOCTYPE html>
    <html dir="rtl" lang="he">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <title>${title}</title>
        <style>
            body { 
                font-family: 'David', 'Times New Roman', serif; 
                direction: rtl; 
                text-align: right;
                line-height: 1.8;
                margin: 0.7cm;
                font-size: 14pt;
            }
            .main-title { 
                font-size: 24pt; 
                font-weight: bold; 
                text-align: center; 
                margin-bottom: 30px;
                border-bottom: 2px solid #333;
                padding-bottom: 15px;
                color: #2c5530;
            }
            .document-info {
                background-color: #f8f9fa;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 25px;
                border-right: 4px solid #6b9080;
                font-size: 12pt;
            }
            .paragraph-container { 
                margin-bottom: 35px; 
                padding: 20px;
                border: 1px solid #ddd;
                border-radius: 8px;
                background-color: #fafafa;
            }
            .paragraph-header { 
                font-size: 14pt; 
                font-weight: bold; 
                color: #2c5530;
                margin-bottom: 12px;
                background-color: #e8f5e8;
                padding: 8px 12px;
                border-radius: 5px;
                border-right: 3px solid #4a7c59;
            }
            .paragraph-number {
                background-color: #4a7c59;
                color: white;
                padding: 4px 8px;
                border-radius: 50%;
                font-weight: bold;
                margin-left: 10px;
                font-size: 12pt;
            }
            .paragraph-text { 
                font-size: 16pt; 
                font-weight: bold; 
                margin-bottom: 20px;
                color: #1a1a1a;
            }
            .sefaria-link {
                color: #4a7c59;
                text-decoration: none;
                font-weight: bold;
                border-bottom: 1px dotted #4a7c59;
            }
            .sefaria-link:hover {
                color: #2c5530;
                background-color: #f0f8f0;
            }
            .additional-versions-section {
                margin-top: 20px;
                padding-top: 15px;
                border-top: 2px solid #e0e0e0;
            }
            .versions-title {
                font-weight: bold;
                color: #4a7c59;
                margin-bottom: 15px;
                font-size: 14pt;
            }
            .additional-version {
                margin: 15px 0;
                padding: 15px;
                background-color: #f0f8ff;
                border-right: 4px solid #4682b4;
                border-radius: 5px;
            }
            .version-title {
                font-weight: bold;
                color: #4682b4;
                margin-bottom: 8px;
                font-size: 13pt;
            }
            .version-text {
                font-size: 14pt;
                color: #2c3e50;
                line-height: 1.7;
            }
            
            /* ×¢×™×¦×•×‘ ×¤×™×¨×•×©×™× ××§×•××™×™× ×ª×—×ª ×”×¤×™×¡×§×” */
            .paragraph-commentaries-section {
                margin-top: 20px;
                padding-top: 15px;
                border-top: 2px solid #d4a574;
            }
            .paragraph-commentaries-title {
                font-weight: bold;
                color: #8b4513;
                margin-bottom: 15px;
                font-size: 14pt;
                text-align: center;
                background-color: #faf0e6;
                padding: 8px;
                border-radius: 5px;
            }
            .inline-commentary {
                margin: 15px 0;
                padding: 15px;
                background-color: #fffef7;
                border-right: 4px solid #daa520;
                border-radius: 5px;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
            .inline-commentary-header {
                display: flex;
                align-items: center;
                margin-bottom: 10px;
                font-weight: bold;
                color: #8b4513;
                font-size: 13pt;
            }
            .inline-commentary-number {
                background-color: #daa520;
                color: white;
                padding: 4px 8px;
                border-radius: 50%;
                font-weight: bold;
                margin-left: 10px;
                font-size: 11pt;
                min-width: 20px;
                text-align: center;
            }
            .inline-commentary-number a {
                color: white;
                text-decoration: none;
            }
            .inline-commentary-number a:hover {
                text-decoration: underline;
            }
            .inline-commentary-title {
                flex: 1;
            }
            .inline-commentary-text {
                font-size: 13pt;
                color: #2c3e50;
                line-height: 1.6;
                margin-bottom: 8px;
                font-style: italic;
            }
            .inline-commentary-link {
                color: #8b4513;
                text-decoration: none;
                font-size: 10pt;
                font-weight: bold;
            }
            .inline-commentary-link:hover {
                text-decoration: underline;
                color: #654321;
            }
            
            /* ×¢×™×¦×•×‘ ×”×¢×¨×•×ª ×¡×™×•× (×§×™×©×•×¨×™× ××™× ×˜×¨××§×˜×™×‘×™×™×) */
            .endnote-ref {
                color: #8b4513;
                font-weight: bold;
                text-decoration: none;
                cursor: pointer;
                vertical-align: super;
                font-size: 0.8em;
            }
            .endnote-ref:hover {
                background-color: #fff8dc;
                border-radius: 2px;
                text-decoration: underline;
            }
            .endnote-back {
                color: #8b4513;
                text-decoration: none;
                font-weight: bold;
            }
            .endnote-back:hover {
                text-decoration: underline;
                background-color: #fff8dc;
            }
            
            /* ×”×¢×¨×•×ª ×©×•×œ×™×™× ×¨×’×™×œ×•×ª (×œ×§×™×©×•×¨×™×) */
            .footnotes-section {
                margin-top: 50px;
                padding-top: 20px;
                border-top: 3px solid #333;
            }
            .footnotes-title {
                font-size: 18pt;
                font-weight: bold;
                color: #333;
                margin-bottom: 20px;
                text-align: center;
            }
            .footnote {
                margin-bottom: 10px;
                font-size: 11pt;
                color: #666;
            }
            .footnote-number {
                font-weight: bold;
                color: #8e44ad;
                margin-left: 5px;
            }
            .footnote-link {
                color: #4a7c59;
                text-decoration: none;
                font-size: 10pt;
            }
            .superscript {
                vertical-align: super;
                font-size: 0.8em;
                color: #8e44ad;
                font-weight: bold;
            }
            .timestamp {
                text-align: center;
                font-size: 10pt;
                color: #888;
                margin-top: 30px;
                border-top: 1px solid #ccc;
                padding-top: 15px;
            }
            @media print {
                body { margin: 1cm; }
                .sefaria-link { color: #000; }
                .endnote-ref { color: #000; }
                .inline-commentary-link { color: #000; }
            }
        </style>
    </head>
    <body>`;

    // ×›×•×ª×¨×ª ×•××™×“×¢ ×¢×œ ×”××¡××š
    html += `
        <div class="main-title">${title}</div>`;

    if (options.includeTimestamp || options.includeLinks) {
        html += `<div class="document-info">`;
        if (options.includeTimestamp) {
            html += `<div><strong>×ª××¨×™×š ×™×¦×™×¨×”:</strong> ${new Date().toLocaleDateString('he-IL')} ${new Date().toLocaleTimeString('he-IL')}</div>`;
        }
        if (options.includeLinks) {
            html += `<div><strong>××§×•×¨:</strong> ×¡×¤×¨×™× - www.sefaria.org</div>`;
        }
        html += `</div>`;
    }

    // ×¢×™×‘×•×“ ×›×œ ×¤×™×¡×§×
    documentData.forEach(paragraph => {
        html += `<div class="paragraph-container">`;

        // ×›×•×ª×¨×ª ×”×¤×™×¡×§×
        if (options.includeParagraphNumbers) {
            html += `
                <div class="paragraph-header">
                    <span class="paragraph-number">${paragraph.paragraphNum}</span>
                    ${paragraph.ref}
                </div>`;
        }

        // ×”×˜×§×¡×˜ ×”×¢×‘×¨×™ ×”×¨××©×™
        let paragraphText = paragraph.hebrewText;

        // ×”×•×¡×¤×ª ×§×™×©×•×¨ ×œ×¡×¤×¨×™× ×× × ×“×¨×©
        if (options.includeLinks) {
            if (options.linkType === 'direct') {
                paragraphText = `<a href="${paragraph.sefariaLink}" class="sefaria-link">${paragraphText}</a>`;
            } else if (options.linkType === 'footnotes') {
                paragraphText += `<span class="superscript">${this.footnoteCounter}</span>`;
                footnotes.push({
                    number: this.footnoteCounter++,
                    text: `×§×™×©×•×¨ ×œ×¡×¤×¨×™×: ${paragraph.sefariaLink}`
                });
            }
        }

        // ×”×•×¡×¤×ª ××¡×¤×•×¨ ×¤×™×¨×•×©×™× (×¢× ×§×™×©×•×¨×™× ××™× ×˜×¨××§×˜×™×‘×™×™×)
        paragraph.commentaries.forEach(commentary => {
            paragraphText += `<sup><a name="endnote_ref_${this.endnoteCounter}"></a><a href="#endnote_${this.endnoteCounter}" class="endnote-ref">${this.endnoteCounter}</a></sup>`;
            this.endnoteCounter++;
        });

        html += `<div class="paragraph-text">${paragraphText}</div>`;

        // ×’×™×¨×¡××•×ª × ×•×¡×¤×•×ª
        if (paragraph.additionalVersions && paragraph.additionalVersions.length > 0) {
            html += `
                <div class="additional-versions-section"> `;
                   
            
            paragraph.additionalVersions.forEach(version => {
                html += `
                    <div class="additional-version">
                        <div class="version-title">${version.title}</div>
                        <div class="version-text">${version.text}</div>
                    </div>`;
            });
            
            html += `</div>`;
        }

        // ×¤×™×¨×•×©×™× ××§×•××™×™× ×ª×—×ª ×”×¤×™×¡×§×”
        if (paragraph.commentaries && paragraph.commentaries.length > 0) {
            html += `
                <div class="paragraph-commentaries-section">
                    <div class="paragraph-commentaries-title">ğŸ“– ×¤×™×¨×•×©×™× ×•×”×¢×¨×•×ª</div>`;
            
            let commentaryCounter = this.endnoteCounter - paragraph.commentaries.length;
            paragraph.commentaries.forEach(commentary => {
                html += `
                    <div class="inline-commentary">
                        <div class="inline-commentary-header">
                            <span class="inline-commentary-number">
                                <a name="endnote_${commentaryCounter}"></a>
                                <a href="#endnote_ref_${commentaryCounter}" class="endnote-back">${commentaryCounter}</a>
                            </span>
                            <span class="inline-commentary-title">${commentary.title}</span>
                        </div>
                        <div class="inline-commentary-text">${commentary.text}</div>
                        <a href="${commentary.link}" class="inline-commentary-link" target="_blank">ğŸ”— ×§×™×©×•×¨ ×œ××§×•×¨ ×‘×¡×¤×¨×™×</a>
                    </div>`;
                commentaryCounter++;
            });
            
            html += `</div>`;
        }

        html += `</div>`;
    });

    // ×”×¢×¨×•×ª ×©×•×œ×™×™× (×§×™×©×•×¨×™× ×‘×œ×‘×“)
    if (options.includeFootnotes && footnotes.length > 0) {
        html += `
            <div class="footnotes-section">
                <div class="footnotes-title">×”×¢×¨×•×ª ×©×•×œ×™×™×</div>`;
        
        footnotes.forEach(footnote => {
            html += `
                <div class="footnote">
                    <span class="footnote-number">${footnote.number}.</span>
                    <a href="${footnote.text.split(': ')[1]}" class="footnote-link">${footnote.text}</a>
                </div>`;
        });
        
        html += `</div>`;
    }

    // ×—×•×ª××ª ×–××Ÿ
    if (options.includeTimestamp) {
        html += `
            <div class="timestamp">
                × ×•×¦×¨ ×‘×××¦×¢×•×ª × ×™×•×•×˜ ×¡×¤×¨×™× ××ª×§×“× ×‘-${new Date().toLocaleDateString('he-IL')} ${new Date().toLocaleTimeString('he-IL')}
            </div>`;
    }

    html += `
    </body>
    </html>`;

    // ×”×•×¨×“×ª ×”×§×•×‘×¥
    const blob = new Blob([html], { type: 'application/msword' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    
    let filename = title.replace(/[^\u0590-\u05FF\w\s-]/g, '');
    if (options.includeLinks) {
        filename += '_×¢×_×§×™×©×•×¨×™×';
    }
    if (documentData.some(p => p.commentaries && p.commentaries.length > 0)) {
        filename += '_×¢×_×¤×™×¨×•×©×™×';
    }
    filename += '.doc';
    
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}
            updateBreadcrumb() {
                const breadcrumb = document.getElementById('breadcrumb');
                let path = 'ğŸ“ ×“×£ ×”×‘×™×ª';

                this.currentPath.forEach(item => {
                    if (item.category) {
                        path += ` > ${item.heCategory || item.category}`;
                    } else if (item.title) {
                        path += ` > ${item.heTitle || item.title}`;
                    }
                });

                breadcrumb.textContent = path;
            }

            updateBackButton() {
                document.getElementById('backBtn').disabled = this.currentPath.length === 0;
            }

            // ×¤×•× ×§×¦×™×•×ª ×¢×–×¨
            log(message, data = null, type = 'info') {
                const debugPanel = document.getElementById('debugPanel');
                const timestamp = new Date().toLocaleTimeString();

                let logEntry = `[${timestamp}] ${message}`;
                if (data) {
                    logEntry += '\n' + JSON.stringify(data, null, 2);
                }

                const logDiv = document.createElement('div');
                logDiv.style.color = type === 'error' ? '#ff6b6b' : type === 'success' ? '#51cf66' : '#74c0fc';
                logDiv.style.marginBottom = '5px';
                logDiv.textContent = logEntry;

                debugPanel.appendChild(logDiv);
                debugPanel.scrollTop = debugPanel.scrollHeight;

                console.log(message, data);
            }

            clearDebug() {
                document.getElementById('debugPanel').innerHTML = '<div>ğŸ“± Enhanced Debug cleared</div>';
            }

            showError(message) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error';
                errorDiv.textContent = message;
                document.body.appendChild(errorDiv);

                setTimeout(() => {
                    if (errorDiv.parentNode) {
                        errorDiv.parentNode.removeChild(errorDiv);
                    }
                }, 5000);
            }

            showSuccess(message) {
                const successDiv = document.createElement('div');
                successDiv.className = 'success';
                successDiv.textContent = message;
                document.body.appendChild(successDiv);

                setTimeout(() => {
                    if (successDiv.parentNode) {
                        successDiv.parentNode.removeChild(successDiv);
                    }
                }, 5000);
            }
        }

        // ×”×ª×—×œ×ª ×”××¤×œ×™×§×¦×™×” ×”××©×•×¤×¨×ª
        document.addEventListener('DOMContentLoaded', () => {
            new EnhancedSefariaNavigator();
        });
    </script>
</body>

</html>