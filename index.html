<!DOCTYPE html>
<html dir="rtl" lang="he">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>× ×™×•×•×˜ ×¡×¤×¨×™× </title>
    <link rel="stylesheet" href="styles.css">

</head>

<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ›ï¸ × ×™×•×•×˜ ×¡×¤×¨×™×</h1>
            <p>× ×•×•×˜ ×‘×¡×¤×¨×™ ×”×§×•×“×© ×‘×—×¨ ×˜×§×¡×˜×™× ×•××¤×¨×©×™×</p>
        </div>

        <!-- ×©×œ×‘ 1: × ×™×•×•×˜ ×œ×§×˜×’×•×¨×™×•×ª -->
        <div id="categoriesStep" class="step">
            <div class="breadcrumb" id="breadcrumb">ğŸ“ ×“×£ ×”×‘×™×ª</div>

            <div class="nav-buttons">
                <button class="btn" id="backBtn" disabled>ğŸ”™ ×—×–×•×¨</button>
                <button class="btn" id="homeBtn">ğŸ  ×“×£ ×”×‘×™×ª</button>
            </div>

            <div id="contentArea">
                <div class="loading">×˜×•×¢×Ÿ...</div>
            </div>
        </div>

        <!-- ×©×œ×‘ 2: ×‘×—×™×¨×ª section (×¢×‘×•×¨ ×¡×¤×¨×™× ××•×¨×›×‘×™×) -->
        <div id="sectionStep" class="step hidden">
            <div class="breadcrumb" id="sectionBreadcrumb">ğŸ“ ×‘×—×™×¨×ª ×—×œ×§</div>

            <div class="nav-buttons">
                <button class="btn" id="backToBookFromSectionBtn">ğŸ”™ ×—×–×•×¨ ×œ×¡×¤×¨</button>
                <button class="btn" id="homeFromSectionBtn">ğŸ  ×“×£ ×”×‘×™×ª</button>
            </div>

            <div class="section">
                <h3>ğŸ“– ×¡×¤×¨ × ×‘×—×¨: <span id="selectedBookTitleSection"></span></h3>
                <h3>ğŸ“‘ ×‘×—×¨ ×—×œ×§:</h3>
                <select id="sectionSelect">
                    <option value="">×‘×—×¨ ×—×œ×§...</option>
                </select>
            </div>
        </div>

        <!-- ×©×œ×‘ 3: ×‘×—×™×¨×ª ×¤×¨×§ -->
        <div id="chapterStep" class="step hidden">
            <div class="breadcrumb" id="chapterBreadcrumb">ğŸ“ ×‘×—×™×¨×ª ×¤×¨×§</div>

            <div class="nav-buttons">
                <button class="btn" id="backToSectionBtn">ğŸ”™ ×—×–×•×¨ ×œ×—×œ×§</button>
                <button class="btn" id="backToBookBtn">ğŸ”™ ×—×–×•×¨ ×œ×¡×¤×¨</button>
                <button class="btn" id="homeFromChapterBtn">ğŸ  ×“×£ ×”×‘×™×ª</button>
            </div>

            <div class="section">
                <h3>ğŸ“– × ×‘×—×¨: <span id="selectedBookTitle"></span></h3>
                <h3 id="selectedSectionTitle" class="hidden">ğŸ“‘ ×—×œ×§: <span id="selectedSectionName"></span></h3>
                <h3>ğŸ”¢ ×‘×—×¨ ×¤×¨×§:</h3>
                <select id="chapterSelect">
                    <option value="">×‘×—×¨ ×¤×¨×§...</option>
                </select>
            </div>
        </div>

        <!-- ×©×œ×‘ 4: ×‘×—×™×¨×ª ×¤×™×¡×§××•×ª ×•×’×™×¨×¡××•×ª -->
        <div id="paragraphStep" class="step hidden">
            <div class="breadcrumb" id="paragraphBreadcrumb">ğŸ“ ×‘×—×™×¨×ª ×¤×™×¡×§××•×ª</div>

            <div class="nav-buttons">
                <button class="btn" id="backToChapterBtn">ğŸ”™ ×—×–×•×¨ ×œ×¤×¨×§</button>
                <button class="btn" id="homeFromParagraphBtn">ğŸ  ×“×£ ×”×‘×™×ª</button>
            </div>

            <div class="section">
                <h3>ğŸ“„ ×¤×¨×§ × ×‘×—×¨: <span id="selectedChapterTitle"></span></h3>

                <div class="paragraph-selector">
                    <div>
                        <label>×¤×™×¡×§× ×”×ª×—×œ×”:</label>
                        <select id="startParagraph">
                            <option value="">×‘×—×¨ ×”×ª×—×œ×”...</option>
                        </select>
                    </div>
                    <div>
                        <label>×¤×™×¡×§× ×¡×•×£:</label>
                        <select id="endParagraph">
                            <option value="">×‘×—×¨ ×¡×•×£...</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="section">
                <h3>ğŸ“š ×’×™×¨×¡××•×ª × ×•×¡×¤×•×ª:</h3>
                <div id="versionsContainer" class="checkbox-group">
                    <div>×‘×—×¨ ×¤×™×¡×§××•×ª ×ª×—×™×œ×”</div>
                </div>
            </div>

            <div class="section">
                <h3>ğŸ“ ××¤×¨×©×™×:</h3>
                <div id="commentariesContainer" class="checkbox-group">
                    <div>×‘×—×¨ ×¤×™×¡×§××•×ª ×ª×—×™×œ×”</div>
                </div>
            </div>

            <button class="generate-btn" id="generateBtn" disabled>ğŸ“„ ×™×¦×•×¨ ××¡××š</button>
            <div class="loading hidden" id="generateLoading">××™×™×¦×¨ ××¡××š...</div>
        </div>

        <!-- ×¤×× ×œ ×“×™×‘×•×’ -->
        <div class="section">
            <h3>ğŸ”§ ×“×™×‘×•×’:</h3>
            <button class="btn" id="clearDebugBtn">ğŸ—‘ï¸ × ×§×”</button>
            <div class="debug-panel" id="debugPanel">
                <div>ğŸ“± Application started</div>
            </div>
        </div>
    </div>

    <script>
        class SefariaNavigator {
            constructor() {
    this.baseUrl = 'https://www.sefaria.org/api';
    this.currentPath = [];
    this.currentBook = null;
    this.currentSection = null;
    this.currentChapter = null;
    this.bookData = null;
    this.chapterData = null;
    this.commentaryCache = new Map(); // ×—×©×•×‘ ×©×™×”×™×” cache ×–×”
    
    this.init();
}

            init() {
                this.log('ğŸš€ Starting Sefaria Navigator...');
                this.setupEventListeners();
                this.loadCategories();
            }

            setupEventListeners() {
                // × ×™×•×•×˜
                document.getElementById('backBtn').addEventListener('click', () => this.goBack());
                document.getElementById('homeBtn').addEventListener('click', () => this.goHome());
                document.getElementById('backToBookFromSectionBtn').addEventListener('click', () => this.backToBook());
                document.getElementById('homeFromSectionBtn').addEventListener('click', () => this.goHome());
                document.getElementById('backToSectionBtn').addEventListener('click', () => this.backToSection());
                document.getElementById('backToBookBtn').addEventListener('click', () => this.backToBook());
                document.getElementById('homeFromChapterBtn').addEventListener('click', () => this.goHome());
                document.getElementById('backToChapterBtn').addEventListener('click', () => this.backToChapter());
                document.getElementById('homeFromParagraphBtn').addEventListener('click', () => this.goHome());

                // ×‘×—×™×¨×•×ª
                document.getElementById('sectionSelect').addEventListener('change', () => this.onSectionSelect());
                document.getElementById('chapterSelect').addEventListener('change', () => this.onChapterSelect());
                document.getElementById('startParagraph').addEventListener('change', () => this.onParagraphRangeChange());
                document.getElementById('endParagraph').addEventListener('change', () => this.onParagraphRangeChange());

                // ×™×¦×™×¨×ª ××¡××š
                document.getElementById('generateBtn').addEventListener('click', () => this.generateDocument());

                // ×“×™×‘×•×’
                document.getElementById('clearDebugBtn').addEventListener('click', () => this.clearDebug());
            }
goBack() {

    if (this.currentPath.length > 0) {
        this.currentPath.pop();
        if (this.currentPath.length === 0) {
            this.loadCategories();
        } else {
            const parent = this.currentPath[this.currentPath.length - 1];
            this.navigateToCategory(parent);
            this.currentPath.pop();
        }
        this.updateBreadcrumb();
        this.updateBackButton();
    } else {
    }
}


            goHome() {
                // ××™×¤×•×¡ ×›×œ ×”× ×ª×•× ×™×
                this.currentPath = [];
                this.currentBook = null;
                this.currentSection = null;
                this.currentChapter = null;

                // ×”×¡×ª×¨×ª ×›×œ ×”×¦×¢×“×™× ×¤×¨×˜ ×œ×¦×¢×“ ×”×¨××©×•×Ÿ
                document.getElementById('categoriesStep').classList.remove('hidden');
                document.getElementById('sectionStep').classList.add('hidden');
                document.getElementById('chapterStep').classList.add('hidden');
                document.getElementById('paragraphStep').classList.add('hidden');

                // ×˜×¢×™× ×ª ×”×§×˜×’×•×¨×™×•×ª ××—×“×©
                this.loadCategories();
                this.updateBreadcrumb();
                this.updateBackButton();

                this.log('ğŸ  ×—×–×¨×” ×œ×“×£ ×”×‘×™×ª');
            }

            backToBook() {
                // ××™×¤×•×¡ ×”×¡×§×©×Ÿ ×”× ×•×›×—×™
                this.currentSection = null;

                // ×”×¡×ª×¨×ª ×›×œ ×”×¦×¢×“×™× ××œ×‘×“ ×¦×¢×“ ×”×§×˜×’×•×¨×™×•×ª
                document.getElementById('sectionStep').classList.add('hidden');
                document.getElementById('chapterStep').classList.add('hidden');
                document.getElementById('paragraphStep').classList.add('hidden');
                document.getElementById('categoriesStep').classList.remove('hidden');

                this.log('ğŸ“– ×—×–×¨×” ×œ×‘×—×™×¨×ª ×¡×¤×¨');
            }

            backToSection() {
                // ×”×¡×ª×¨×ª ×¦×¢×“×™ ×”×¤×¨×§ ×•×”×¤×™×¡×§××•×ª
                document.getElementById('chapterStep').classList.add('hidden');
                document.getElementById('paragraphStep').classList.add('hidden');

                // ×”×¦×’×ª ×¦×¢×“ ×”×¡×§×©×Ÿ
                document.getElementById('sectionStep').classList.remove('hidden');

                this.log('ğŸ“‘ ×—×–×¨×” ×œ×‘×—×™×¨×ª ×¡×§×©×Ÿ');
            }

            backToChapter() {
                // ×”×¡×ª×¨×ª ×¦×¢×“ ×”×¤×™×¡×§××•×ª
                document.getElementById('paragraphStep').classList.add('hidden');

                // ×”×¦×’×ª ×¦×¢×“ ×”×¤×¨×§
                document.getElementById('chapterStep').classList.remove('hidden');

                this.log('ğŸ”¢ ×—×–×¨×” ×œ×‘×—×™×¨×ª ×¤×¨×§');
            }
            async loadCategories() {
                try {
                    this.log('ğŸ“š Loading categories...');
                    const response = await fetch(`${this.baseUrl}/index`);
                    const data = await response.json();

                    this.displayCategories(data);
                } catch (error) {
                    this.log(`âŒ Error loading categories: ${error.message}`, 'error');
                    this.showError('×©×’×™××” ×‘×˜×¢×™× ×ª ×”×§×˜×’×•×¨×™×•×ª');
                }
            }

            displayCategories(categories) {
                const contentArea = document.getElementById('contentArea');
                contentArea.innerHTML = '';

                if (!Array.isArray(categories)) {
                    this.log('âŒ Categories is not an array:', categories, 'error');
                    return;
                }

                const grid = document.createElement('div');
                grid.className = 'grid';

                categories.forEach(category => {
                    if (category.category) {
                        const card = this.createCard(
                            category.category,
                            category.heCategory || '',
                            () => this.navigateToCategory(category)
                        );
                        grid.appendChild(card);
                    }
                });

                contentArea.appendChild(grid);
                this.updateBreadcrumb();
            }

            async navigateToCategory(category) {
                try {
                    this.log(`ğŸ” Navigating to category: ${category.category}`);
                    this.currentPath.push(category);

                    if (category.contents) {
                        this.displayContents(category.contents);
                    } else {
                        // ×˜×¢×Ÿ ×ª×•×›×Ÿ ×”×§×˜×’×•×¨×™×”
                        const response = await fetch(`${this.baseUrl}/index/${encodeURIComponent(category.category)}`);
                        const data = await response.json();

                        this.displayContents(data.contents || []);
                    }

                    this.updateBreadcrumb();
                    this.updateBackButton();
                } catch (error) {
                    this.log(`âŒ Error navigating to category: ${error.message}`, 'error');
                }
            }

            displayContents(contents) {
                const contentArea = document.getElementById('contentArea');
                contentArea.innerHTML = '';

                if (!Array.isArray(contents)) {
                    this.log('âŒ Contents is not an array:', contents, 'error');
                    return;
                }

                const grid = document.createElement('div');
                grid.className = 'grid';

                contents.forEach(item => {
                    if (item.category) {
                        // ×–×•×”×™ ×ª×ª-×§×˜×’×•×¨×™×”
                        const card = this.createCard(
                            item.category,
                            item.heCategory || '',
                            () => this.navigateToCategory(item)
                        );
                        grid.appendChild(card);
                    } else if (item.title) {
                        // ×–×”×• ×¡×¤×¨
                        const card = this.createCard(
                            item.title,
                            item.heTitle || '',
                            () => this.selectBook(item)
                        );
                        card.classList.add('book-card');
                        grid.appendChild(card);
                    }
                });

                contentArea.appendChild(grid);
            }

            createCard(title, subtitle, onClick) {
                const card = document.createElement('div');
                card.className = 'card';
                card.onclick = onClick;

                const titleEl = document.createElement('div');
                titleEl.className = 'card-title';
                titleEl.textContent = subtitle;

                const subtitleEl = document.createElement('div');
                subtitleEl.className = 'card-subtitle';
                subtitleEl.textContent = title;

                card.appendChild(titleEl);
                card.appendChild(subtitleEl);

                return card;
            }

async selectBook(book) {
    try {
        this.log(`ğŸ“– Selected book: ${book.title}`);
        this.currentBook = book;
        
        // × ×§×” cache ×¤×™×¨×•×©×™× ×¢×‘×•×¨ ×¡×¤×¨ ×—×“×©
        this.commentaryCache.clear();
        this.log('ğŸ§¹ Cleared commentary cache');

        // ×˜×¢×Ÿ ××™×“×¢ ×¢×œ ×”×¡×¤×¨ ×-API v2 raw index
        const v2Response = await fetch(`${this.baseUrl}/v2/raw/index/${encodeURIComponent(book.title)}`);
        this.bookData = await v2Response.json();
        

        // ×‘×“×•×§ ×× ×–×”×• ×¡×¤×¨ ××•×¨×›×‘ (×¢× sections) ××• ×¤×©×•×˜
        if (this.bookData.schema && this.bookData.schema.nodes && this.bookData.schema.nodes.length > 0) {
            this.log(`ğŸ“š Complex book with ${this.bookData.schema.nodes.length} sections`);
            this.showSectionStep();
        } else {
            this.log('ğŸ“– Simple book structure');
            this.showChapterStep();
            this.populateChapters();
        }
    } catch (error) {
        this.log(`âŒ Error selecting book: ${error.message}`, 'error');
        this.showError('×©×’×™××” ×‘×˜×¢×™× ×ª ×”×¡×¤×¨');
    }
}

            showSectionStep() {
                document.getElementById('categoriesStep').classList.add('hidden');
                document.getElementById('sectionStep').classList.remove('hidden');
                document.getElementById('selectedBookTitleSection').textContent = this.currentBook.heTitle || this.currentBook.title;
                this.populateSections();
            }

            populateSections() {
                const sectionSelect = document.getElementById('sectionSelect');
                sectionSelect.innerHTML = '<option value="">×‘×—×¨ ×—×œ×§...</option>';


                if (this.bookData.schema && this.bookData.schema.nodes) {
                    this.bookData.schema.nodes.forEach((section, index) => {
                        const option = document.createElement('option');
                        option.value = section.key || section.title;
                        option.textContent = section.titles[1].text || section.title;
                        option.dataset.index = index;
                        sectionSelect.appendChild(option);
                    });
                    this.log(`ğŸ“‘ Added ${this.bookData.schema.nodes.length} sections`);
                }
            }

            async onSectionSelect() {
                const sectionSelect = document.getElementById('sectionSelect');
                const selectedOption = sectionSelect.options[sectionSelect.selectedIndex];

                if (!selectedOption.value) return;


                this.currentSection = {
                    key: selectedOption.value,
                    index: parseInt(selectedOption.dataset.index),
                    title: selectedOption.textContent,
                    data: this.bookData.schema.nodes[selectedOption.dataset.index],
                };

                this.log(`ğŸ“‘ Selected section: ${this.currentSection.title}`, this.currentSection);
                this.showChapterStep();
                this.populateChaptersForSection();
            }

            populateChaptersForSection() {
                const chapterSelect = document.getElementById('chapterSelect');
                chapterSelect.innerHTML = '<option value="">×‘×—×¨ ×¤×¨×§...</option>';

                const sectionData = this.currentSection.data;

                // ×—×©×‘ ×›××” ×¤×¨×§×™× ×™×© ×‘×¡×§×©×Ÿ ×”×–×”
                if (sectionData.index_offsets_by_depth && sectionData.index_offsets_by_depth["2"]) {
                    const offsets = sectionData.index_offsets_by_depth["2"];
                    const numChapters = offsets.length;

                    this.log(`ğŸ“– Section has ${numChapters} chapters`);

                    for (let i = 1; i <= numChapters; i++) {
                        const option = document.createElement('option');
                        option.value = i;
                        option.textContent = `×¤×¨×§ ${i}`;
                        chapterSelect.appendChild(option);
                    }

                    // ×¢×“×›×Ÿ UI
                    document.getElementById('selectedSectionTitle').classList.remove('hidden');
                    console.log(this.currentSection, "current section");

                    document.getElementById('selectedSectionName').textContent = this.currentSection.title;
                } else {
                    this.log('âŒ No chapter information found for section', 'error');
                }
            }

            showChapterStep() {
                document.getElementById('categoriesStep').classList.add('hidden');
                document.getElementById('sectionStep').classList.add('hidden');
                document.getElementById('chapterStep').classList.remove('hidden');
                document.getElementById('selectedBookTitle').textContent = this.currentBook.heTitle || this.currentBook.title;

                // ×”×¡×ª×¨ ××• ×”×¦×’ ××ª ××™×“×¢ ×”×¡×§×©×Ÿ
                if (this.currentSection) {
                    document.getElementById('selectedSectionTitle').classList.remove('hidden');
                    document.getElementById('selectedSectionName').textContent = this.currentSection.title;
                    document.getElementById('backToSectionBtn').style.display = 'inline-block';
                } else {
                    document.getElementById('selectedSectionTitle').classList.add('hidden');
                    document.getElementById('backToSectionBtn').style.display = 'none';
                }
            }

           populateChapters() {
    const chapterSelect = document.getElementById('chapterSelect');
    chapterSelect.innerHTML = '<option value="">×‘×—×¨ ×¤×¨×§...</option>';

    // ×‘×“×•×§ ××ª ×”××‘× ×” ×©×œ ×”×¡×¤×¨ ×œ×§×‘×œ×ª ××¡×¤×¨ ×”×¤×¨×§×™×
    let chapterCount = 0;
    
    this.log('ğŸ“Š Book structure:', this.bookData);
    
    // × ×¡×” ×œ××¦×•× ××ª ××¡×¤×¨ ×”×¤×¨×§×™× ×‘×“×¨×›×™× ×©×•× ×•×ª ×‘×”×ª×× ×œ××‘× ×” ×”×¡×¤×¨
    if (this.bookData.schema && this.bookData.schema.lengths && this.bookData.schema.lengths.length > 0) {
        // ×©×™××•×© ×‘-schema.lengths ×œ×¡×¤×¨×™× ×—×“×©×™×
        chapterCount = this.bookData.schema.lengths[0];
        this.log(`ğŸ“š Using schema.lengths: ${chapterCount} chapters`);
    } else if (this.bookData.schema && this.bookData.schema.content_counts && this.bookData.schema.content_counts.length > 0) {
        // ×©×™××•×© ×‘-schema.content_counts ×œ×—×œ×§ ××”×¡×¤×¨×™×
        chapterCount = this.bookData.schema.content_counts.length;
        this.log(`ğŸ“š Using schema.content_counts: ${chapterCount} chapters`);
    } else if (this.bookData.lengths && this.bookData.lengths.length > 0) {
        // ×©×™××•×© ×‘-lengths ×œ×¡×¤×¨×™× ×™×©× ×™×
        chapterCount = this.bookData.lengths[0];
        this.log(`ğŸ“š Using book.lengths: ${chapterCount} chapters`);
    } else if (this.bookData.alt_structs && this.bookData.alt_structs.Parasha && this.bookData.alt_structs.Parasha.nodes) {
        // ×”×ª××•×“×“×•×ª ×¢× ×¡×¤×¨×™× ×©×××•×¨×’× ×™× ×œ×¤×™ ×¤×¨×©×•×ª
        chapterCount = this.estimateChaptersFromParashiot(this.bookData.alt_structs.Parasha.nodes);
        this.log(`ğŸ“š Estimated from Parashot: ${chapterCount} chapters`);
    } else {
        // ×× ××™×Ÿ ×œ× ×• ××™×“×¢ ××“×•×™×§, × ×©×ª××© ×‘××¡×¤×¨ ×‘×¨×™×¨×ª ××—×“×œ
        chapterCount = 50; // ××¡×¤×¨ ×’×“×•×œ ×œ×—×•××©
        this.log(`ğŸ“š Using default chapter count: ${chapterCount}`);
    }
    
    // ×”×•×¡×£ ××ª ×”××¤×©×¨×•×™×•×ª ×œ×‘×—×™×¨×ª ×”×¤×¨×§
    for (let i = 1; i <= chapterCount; i++) {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = `×¤×¨×§ ${i}`;
        chapterSelect.appendChild(option);
    }
    
    this.log(`ğŸ“š Added ${chapterCount} chapters to select menu`);
}
// ×¤×•× ×§×¦×™×™×ª ×¢×–×¨ ×œ×”×¢×¨×›×ª ××¡×¤×¨ ×”×¤×¨×§×™× ××¨×©×™××ª ×¤×¨×©×™×•×ª
estimateChaptersFromParashiot(parashiot) {
    try {
        let maxChapter = 0;
        
        for (const parasha of parashiot) {
            if (parasha.wholeRef) {
                // × ×¡×” ×œ×—×œ×¥ ××ª ×”××¡×¤×¨×™× ××”×¤× ×™×”
                const match = parasha.wholeRef.match(/(\d+):(\d+)-(\d+):(\d+)/);
                if (match && match[3]) {
                    const endChapter = parseInt(match[3]);
                    if (endChapter > maxChapter) {
                        maxChapter = endChapter;
                    }
                }
            }
        }
        
        return maxChapter || 50; // ×‘×¨×™×¨×ª ××—×“×œ ×× ×œ× ××¦×× ×•
    } catch (error) {
        this.log(`âŒ Error estimating chapters from parashiot: ${error.message}`, 'error');
        return 50; // ×‘×¨×™×¨×ª ××—×“×œ
    }
}
async onChapterSelect() {
    const chapterNum = document.getElementById('chapterSelect').value;
    if (!chapterNum) return;

    try {
        this.log(`ğŸ“„ Loading chapter ${chapterNum}`);
        this.currentChapter = chapterNum;

        // ×‘× ×” ××ª ×”×”×¤× ×™×” ×‘×”×ª×× ×œ×¡×•×’ ×”×¡×¤×¨
        let chapterRef;
        if (this.currentSection) {
            chapterRef = `${this.currentBook.title}, ${this.currentSection.key} ${chapterNum}`;
        } else {
            chapterRef = `${this.currentBook.title} ${chapterNum}`;
        }

        this.log(`ğŸ”— Chapter reference: ${chapterRef}`);

        // ×©×œ×•×£ ××ª ××™×“×¢ ×”×¤×¨×§ ×›×“×™ ×œ×§×‘×œ ×›×•×ª×¨×•×ª × ×›×•× ×•×ª
        const chapterInfoResponse = await fetch(`${this.baseUrl}/texts/${encodeURIComponent(chapterRef)}`);
        const chapterInfo = await chapterInfoResponse.json();

        // ×©××•×¨ ××™×“×¢ × ×•×¡×£ ×¢×œ ×”×¤×¨×§
        this.chapterInfo = {
            heTitle: chapterInfo.heTitle || '',
            heSectionRef: chapterInfo.heSectionRef || '',
            bookTitle: chapterInfo.book || this.currentBook.title,
            heBook: chapterInfo.heBook || '',
            // ×˜×¤×œ ×‘××§×¨×” ×©××™×Ÿ offset
            offset: chapterInfo.index_offsets_by_depth?.["2"]?.[0] || 0
        };
        

        // ×¢×‘×•×¨ ×¡×¤×¨×™× ×¤×©×•×˜×™×, ×× ×—× ×• ×›×‘×¨ ×§×™×‘×œ× ×• ××ª ×›×œ ×”××™×“×¢ ×‘×©×œ×‘ ×–×”
        const isSimpleBook = !this.currentSection;
        if (isSimpleBook && chapterInfo.he && Array.isArray(chapterInfo.he)) {
            this.chapterData = chapterInfo;
            this.log('ğŸ“š Direct use of chapter data for simple book');
        } else {
            // ×©×œ×•×£ ×¤×™×¡×§× ××—×¨ ×¤×™×¡×§× ×‘××§×•× ×›×œ ×”×¤×¨×§ ×¢×‘×•×¨ ×¡×¤×¨×™× ××•×¨×›×‘×™×
            await this.loadParagraphByParagraph(chapterRef);
        }

        this.showParagraphStep();
        this.populateParagraphs();
    } catch (error) {
        this.log(`âŒ Error loading chapter: ${error.message}`, 'error');
        this.showError('×©×’×™××” ×‘×˜×¢×™× ×ª ×”×¤×¨×§');
    }
}

           async loadParagraphByParagraph(chapterRef) {
    this.log(`ğŸ“ Loading paragraphs for: ${chapterRef}`);
    
    // ×‘×“×•×§ ×× ×–×” ×¡×¤×¨ ×¤×©×•×˜ ××• ××•×¨×›×‘
    const isSimpleBook = !this.currentSection;
    
    if (isSimpleBook) {
        // ×¢×‘×•×¨ ×¡×¤×¨ ×¤×©×•×˜ - ×˜×¢×Ÿ ××ª ×›×œ ×”×¤×¨×§ ×‘×‘×ª ××—×ª
        try {
            this.log(`ğŸ“š Loading entire chapter at once for simple book: ${chapterRef}`);
            const response = await fetch(`${this.baseUrl}/texts/${encodeURIComponent(chapterRef)}`);
            
            if (response.ok) {
                const chapterData = await response.json();
                
                if (chapterData.he && Array.isArray(chapterData.he)) {
                    this.chapterData = chapterData;
                    this.log(`âœ… Successfully loaded ${chapterData.he.length} paragraphs at once`);
                    return;
                } else {
                    this.log(`âš ï¸ Unexpected format for chapter data`);
                }
            } else {
                this.log(`âŒ Failed to load chapter: ${response.status}`);
            }
        } catch (error) {
            this.log(`âŒ Error loading full chapter: ${error.message}`);
        }
    }
    const chapterNum = parseInt(this.currentChapter);
    let expectedParagraphs = this.getExpectedParagraphCount(chapterNum);
    
    if (expectedParagraphs) {
        this.log(`ğŸ“Š Expected ${expectedParagraphs} paragraphs for chapter ${chapterNum}`);
        await this.loadExactParagraphCount(chapterRef, expectedParagraphs);
    } else {
        this.log('ğŸ“Š No expected count, using discovery method');
        await this.loadParagraphsDiscovery(chapterRef);
    }
}
            getExpectedParagraphCount(chapterNum) {
                // × ×¡×” ×œ××¦×•× ××ª ××¡×¤×¨ ×”×¤×™×¡×§××•×ª ×”×¦×¤×•×™ ××”××™×“×¢ ×©×™×© ×œ× ×•
                let counts = null;

                if (this.currentSection && this.currentSection.data.content_counts) {
                    counts = this.currentSection.data.content_counts;
                } else if (this.bookData.schema && this.bookData.schema.content_counts) {
                    counts = this.bookData.schema.content_counts;
                } else if (this.bookData.schema && this.bookData.schema.lengths) {
                    counts = this.bookData.schema.lengths;
                } else if (this.bookData.lengths && this.bookData.lengths.length > 1) {
                    counts = this.bookData.lengths[1]; // ×¢×‘×•×¨ ×¡×¤×¨×™× ×¤×©×•×˜×™×
                }

                if (counts && Array.isArray(counts) && counts[chapterNum - 1]) {
                    return counts[chapterNum - 1];
                }

                return null;
            }

            async loadExactParagraphCount(chapterRef, expectedCount) {
                this.log(`ğŸ“š Loading ${expectedCount} paragraphs exactly`);

                this.chapterData = { he: [] };

                for (let paragraphNum = 1; paragraphNum <= expectedCount; paragraphNum++) {
                    const paragraphRef = `${chapterRef}:${paragraphNum}`;

                    try {
                        this.log(`ğŸ“„ Loading paragraph ${paragraphNum}/${expectedCount}: ${paragraphRef}`);

                        const response = await fetch(`${this.baseUrl}/texts/${encodeURIComponent(paragraphRef)}`);

                        if (response.ok) {
                            const paragraphData = await response.json();

                            if (paragraphData.he) {
                                const paragraphText = Array.isArray(paragraphData.he) ?
                                    paragraphData.he[0] || paragraphData.he.join(' ') : paragraphData.he;

                                if (paragraphText && paragraphText.trim()) {
                                    this.chapterData.he.push(paragraphText);
                                    this.log(`âœ… Loaded paragraph ${paragraphNum}: ${paragraphText.substring(0, 50)}...`);
                                } else {
                                    this.chapterData.he.push(''); // ×©××•×¨ ××§×•× ×¨×™×§
                                    this.log(`âš ï¸ Empty paragraph ${paragraphNum}`);
                                }
                            } else {
                                this.chapterData.he.push(''); // ×©××•×¨ ××§×•× ×¨×™×§
                                this.log(`âš ï¸ No Hebrew text for paragraph ${paragraphNum}`);
                            }
                        } else {
                            this.chapterData.he.push(''); // ×©××•×¨ ××§×•× ×¨×™×§
                            this.log(`âŒ Failed to load paragraph ${paragraphNum}: ${response.status}`);
                        }

                        // ×”×©×”×™×” ×§×¦×¨×” ×‘×™×Ÿ ×‘×§×©×•×ª
                        await new Promise(resolve => setTimeout(resolve, 100));

                    } catch (error) {
                        this.log(`âŒ Error loading paragraph ${paragraphNum}: ${error.message}`);
                        this.chapterData.he.push(''); // ×©××•×¨ ××§×•× ×¨×™×§
                    }
                }

                // ×”×¡×¨ ×¤×™×¡×§××•×ª ×¨×™×§×•×ª ××”×¡×•×£
                while (this.chapterData.he.length > 0 && !this.chapterData.he[this.chapterData.he.length - 1].trim()) {
                    this.chapterData.he.pop();
                }

                this.log(`ğŸ“Š Loaded ${this.chapterData.he.length} paragraphs out of ${expectedCount} expected`);
            }

            async loadParagraphsDiscovery(chapterRef) {
                this.log(`ğŸ” Discovering paragraphs for: ${chapterRef}`);

                // × ×¡×” ×œ×˜×¢×•×Ÿ ××ª ×›×œ ×”×¤×¨×§ ×§×•×“×
                try {
                    const fullChapterResponse = await fetch(`${this.baseUrl}/texts/${encodeURIComponent(chapterRef)}`);

                    if (fullChapterResponse.ok) {
                        const fullChapterData = await fullChapterResponse.json();

                        if (fullChapterData.he && Array.isArray(fullChapterData.he)) {
                            this.chapterData = fullChapterData;
                            this.log(`âœ… Loaded ${fullChapterData.he.length} paragraphs from full chapter`);
                            return;
                        }
                    }
                } catch (error) {
                    this.log(`âŒ Error loading full chapter: ${error.message}`);
                }

                // ×× ×–×” ×œ× ×¢×‘×“, × ×©×ª××© ×‘×©×™×˜×ª ×”×’×™×œ×•×™ ×”××§×•×¨×™×ª
                await this.discoverExistingParagraphs(chapterRef);
            }


            async discoverExistingParagraphs(chapterRef) {
                this.log(`ğŸ” Discovering existing paragraphs for: ${chapterRef}`);

                this.chapterData = { he: [] };
                const maxAttempts = 200;
                const maxFailures = 10; // ×¢×¦×•×¨ ××—×¨×™ 10 ×›×™×©×œ×•× ×•×ª ×¨×¦×•×¤×™×
                let consecutiveFailures = 0;

                for (let paragraphNum = 1; paragraphNum <= maxAttempts; paragraphNum++) {
                    const paragraphRef = `${chapterRef}:${paragraphNum}`;

                    try {
                        this.log(`ğŸ” Trying paragraph ${paragraphNum}`);

                        const response = await fetch(`${this.baseUrl}/texts/${encodeURIComponent(paragraphRef)}`);

                        if (response.ok) {
                            const paragraphData = await response.json();

                            if (paragraphData.he && paragraphData.he.length > 0) {
                                const paragraphText = Array.isArray(paragraphData.he) ?
                                    paragraphData.he[0] : paragraphData.he;

                                if (paragraphText && paragraphText.trim()) {
                                    this.chapterData.he.push(paragraphText);
                                    this.log(`âœ… Found paragraph ${paragraphNum}`);
                                    consecutiveFailures = 0;
                                } else {
                                    consecutiveFailures++;
                                }
                            } else {
                                consecutiveFailures++;
                            }
                        } else if (response.status === 404) {
                            consecutiveFailures++;
                            this.log(`â­ï¸ Paragraph ${paragraphNum} not found (404)`);
                        } else {
                            consecutiveFailures++;
                            this.log(`âŒ Error ${response.status} for paragraph ${paragraphNum}`);
                        }

                        // ×¢×¦×•×¨ ×× ×™×© ×™×•×ª×¨ ××“×™ ×›×™×©×œ×•× ×•×ª ×¨×¦×•×¤×™×
                        if (consecutiveFailures >= maxFailures) {
                            this.log(`ğŸ›‘ Stopping after ${maxFailures} consecutive failures`);
                            break;
                        }

                        // ×”×©×”×™×” ×§×¦×¨×” ×‘×™×Ÿ ×‘×§×©×•×ª
                        await new Promise(resolve => setTimeout(resolve, 50));

                    } catch (error) {
                        this.log(`âŒ Error fetching paragraph ${paragraphNum}: ${error.message}`);
                        consecutiveFailures++;

                        if (consecutiveFailures >= maxFailures) {
                            break;
                        }
                    }
                }

                this.log(`ğŸ“Š Discovery complete: ${this.chapterData.he.length} paragraphs found`);

                if (this.chapterData.he.length === 0) {
                    this.log('âš ï¸ No paragraphs found, trying final fallback');
                    await this.loadChapterFallback(chapterRef);
                }
            }

            async loadChapterFallback(chapterRef) {
                // ×©×œ×•×£ ××ª ×›×œ ×”×¤×¨×§
                try {
                    const response = await fetch(`${this.baseUrl}/texts/${encodeURIComponent(chapterRef)}`);
                    const data = await response.json();


                    if (data.he && Array.isArray(data.he)) {
                        this.chapterData = data;
                        this.log(`ğŸ“š Fallback: loaded ${data.he.length} paragraphs from full chapter`);
                    } else if (data.he) {
                        this.chapterData = { he: [data.he] };
                        this.log('ğŸ“š Fallback: loaded single paragraph');
                    }
                } catch (error) {
                    this.log(`âŒ Fallback also failed: ${error.message}`, 'error');
                }
            }

            showParagraphStep() {
                document.getElementById('chapterStep').classList.add('hidden');
                document.getElementById('paragraphStep').classList.remove('hidden');

                let title = `${this.currentBook.heTitle || this.currentBook.title}`;
                if (this.currentSection) {
                    title += `, ${this.currentSection.title}`;
                }
                title += ` ×¤×¨×§ ${this.currentChapter}`;

                document.getElementById('selectedChapterTitle').textContent = title;
            }

            async onParagraphRangeChange() {
                const start = document.getElementById('startParagraph').value;
                const end = document.getElementById('endParagraph').value;

                if (start && end) {
                    this.log(`ğŸ“ Paragraph range selected: ${start} to ${end}`);

                    await this.loadVersions();
                    await this.loadCommentaries();

                    document.getElementById('generateBtn').disabled = false;
                } else {
                    document.getElementById('generateBtn').disabled = true;
                }
            }

            async loadVersions() {
                try {
                    this.log('ğŸ“š Loading versions...');
                    const response = await fetch(`${this.baseUrl}/texts/versions/${encodeURIComponent(this.currentBook.title)}`);
                    const versions = await response.json();


                    const container = document.getElementById('versionsContainer');
                    container.innerHTML = '';

                    if (Array.isArray(versions)) {
                        versions.forEach(version => {
                            if (version.languageFamilyName !== 'hebrew' || !version.isPrimary) {
                                const label = document.createElement('label');
                                const checkbox = document.createElement('input');
                                checkbox.type = 'checkbox';
                                checkbox.value = version.versionTitle;
                                checkbox.dataset.language = version.languageFamilyName;
                                checkbox.dataset.title = version.versionTitle;

                                label.appendChild(checkbox);
                                label.appendChild(document.createTextNode(`${version.versionTitle} (${version.languageFamilyName})`));
                                container.appendChild(label);
                            }
                        });
                    }
                } catch (error) {
                    this.log(`âŒ Error loading versions: ${error.message}`, 'error');
                }
            }

     populateParagraphs() {
    const startSelect = document.getElementById('startParagraph');
    const endSelect = document.getElementById('endParagraph');
    
    startSelect.innerHTML = '<option value="">×‘×—×¨ ×”×ª×—×œ×”...</option>';
    endSelect.innerHTML = '<option value="">×‘×—×¨ ×¡×•×£...</option>';

    if (this.chapterData.he && Array.isArray(this.chapterData.he)) {
        const numParagraphs = this.chapterData.he.length;
        this.log(`ğŸ“ Chapter has ${numParagraphs} paragraphs`);

        // ×§×‘×¢ ××ª ×”×ª×•×•×™×ª ×”××ª××™××” ×‘×”×ª×‘×¡×¡ ×¢×œ ×¡×•×’ ×”×¡×¤×¨
        const paraLabel = this.currentSection ? '×¤×™×¡×§×' : '×¤×¡×•×§';
        
        // ×§×‘×¢ ××ª ×”×”×™×¡×˜ ×œ×¤×¡×•×§×™×
        let offset = 0;
        
        // ×× ×™×© ×œ× ×• offset ××”-API, × ×©×ª××© ×‘×•
        if (this.chapterInfo && this.chapterInfo.offset !== undefined) {
            offset = this.chapterInfo.offset;
            this.log(`ğŸ“Š Using API offset: ${offset}`);
        } else {
            this.log(`ğŸ“Š No offset available, using 0`);
        }

        for (let i = 1; i <= numParagraphs; i++) {
            const displayNumber = i + offset;
            
            const startOption = document.createElement('option');
            startOption.value = displayNumber;
            startOption.textContent = `${paraLabel} ${displayNumber}`;
            startSelect.appendChild(startOption);

            const endOption = document.createElement('option');
            endOption.value = displayNumber;
            endOption.textContent = `${paraLabel} ${displayNumber}`;
            endSelect.appendChild(endOption);
        }
        
        // ×•×“× ×©×”-event listeners ×¢×•×‘×“×™×
        this.log('ğŸ”§ Re-ensuring event listeners for paragraph selects');
        startSelect.removeEventListener('change', this.onParagraphRangeChange.bind(this));
        endSelect.removeEventListener('change', this.onParagraphRangeChange.bind(this));
        startSelect.addEventListener('change', this.onParagraphRangeChange.bind(this));
        endSelect.addEventListener('change', this.onParagraphRangeChange.bind(this));
        
    } else {
        this.log('âŒ No paragraph data found in chapter', 'error');
        
        // fallback - ×¦×•×¨ ×›××” ×¤×™×¡×§××•×ª ×›×‘×¨×™×¨×ª ××—×“×œ
        for (let i = 1; i <= 10; i++) {
            const startOption = document.createElement('option');
            startOption.value = i;
            startOption.textContent = `×¤×¡×•×§ ${i}`;
            startSelect.appendChild(startOption);

            const endOption = document.createElement('option');
            endOption.value = i;
            endOption.textContent = `×¤×¡×•×§ ${i}`;
            endSelect.appendChild(endOption);
        }
    }
}
            async generateDocument() {
                try {
                    this.log('ğŸ“„ Generating document...');
                    document.getElementById('generateBtn').disabled = true;
                    document.getElementById('generateLoading').classList.remove('hidden');

                    const start = parseInt(document.getElementById('startParagraph').value);
                    const end = parseInt(document.getElementById('endParagraph').value);

                    // ××™×¡×•×£ ×”×’×™×¨×¡××•×ª ×”× ×‘×—×¨×•×ª
                    const selectedVersions = Array.from(document.querySelectorAll('#versionsContainer input[type="checkbox"]:checked'))
                        .map(cb => {
                            const title = cb.dataset.title;
                            const language = cb.dataset.language;

                            this.log(`ğŸ“ Selected version: ${title} (${language})`);

                            return {
                                title: title,
                                language: language
                            };
                        })
                        .filter(v => v.title && v.language); // ×¡× ×Ÿ ×’×™×¨×¡××•×ª ×œ× ×ª×§×™× ×•×ª

                    // ××™×¡×•×£ ×”××¤×¨×©×™× ×”× ×‘×—×¨×™×
                    const selectedCommentaries = Array.from(document.querySelectorAll('#commentariesContainer input:checked'))
                        .map(cb => cb.value);

                    this.log(`ğŸ“Š Selected range: ${start} to ${end}`);
                    this.log(`ğŸ“š Selected versions:`, selectedVersions);
                    this.log(`ğŸ“ Selected commentaries: ${selectedCommentaries.join(', ') || 'none'}`);



                    // ×©×œ×•×£ ××ª ×›×œ ×”×¤×™×¡×§××•×ª ×‘×˜×•×•×—
                    const documentData = await this.fetchDocumentData(start, end, selectedVersions, selectedCommentaries);

                    // ×™×¦×•×¨ ×§×•×‘×¥ Word
                    this.createWordDocument(documentData);

                    this.log('âœ… Document generated successfully!', 'success');
                    this.showSuccess('×”××¡××š × ×•×¦×¨ ×‘×”×¦×œ×—×”!');

                } catch (error) {
                    this.log(`âŒ Error generating document: ${error.message}`, 'error');
                    this.showError('×©×’×™××” ×‘×™×¦×™×¨×ª ×”××¡××š');
                } finally {
                    document.getElementById('generateBtn').disabled = false;
                    document.getElementById('generateLoading').classList.add('hidden');
                }
            }

      async fetchDocumentData(startParagraph, endParagraph, selectedVersions, selectedCommentaries) {
    const documentData = [];

    this.log(`ğŸ“š Processing paragraphs ${startParagraph} to ${endParagraph}`);

    for (let index = startParagraph; index <= endParagraph; index++) {
        this.log(`ğŸ“„ Processing paragraph ${index}`);

        // ×—×™×©×•×‘ ××™× ×“×§×¡ ×”××¢×¨×š ×‘×”×ª×—×©×‘ ×‘×”×™×¡×˜
        const offset = this.chapterInfo.offset || 0;
        const arrayIndex = index - offset - 1;
        
        this.log(`ğŸ“Š Array index for paragraph ${index}: ${arrayIndex} (offset: ${offset})`);
        
        // ×‘×“×•×§ ×©×”××™× ×“×§×¡ ×ª×§×™×Ÿ
        if (arrayIndex < 0 || arrayIndex >= this.chapterData.he.length) {
            this.log(`âš ï¸ Invalid array index ${arrayIndex} for paragraph ${index}`);
            continue;
        }

        const hebrewText = this.chapterData.he[arrayIndex];
        
        // ×‘× ×” ×”×¤× ×™×” ×œ×¤×™×¡×§× ×‘×¤×•×¨××˜ ×”× ×›×•×Ÿ
        let paragraphRef;
        if (this.currentSection) {
            paragraphRef = `${this.currentBook.title}, ${this.currentSection.key} ${this.currentChapter}:${index}`;
        } else {
            paragraphRef = `${this.currentBook.title} ${this.currentChapter}:${index}`;
        }
        
        this.log(`ğŸ”— Paragraph reference: ${paragraphRef}`);
        
        try {
            // × ×§×” ××ª ×”×˜×§×¡×˜ ×-HTML tags
            const cleanText = hebrewText.replace(/<[^>]*>/g, '').trim();

            if (!cleanText) {
                this.log(`âš ï¸ Empty text for paragraph ${index}`);
                continue;
            }

            // ×©×œ×•×£ ××¤×¨×©×™× ×œ×¤×™×¡×§× ×–×•
            const commentaries = await this.fetchCommentariesForParagraph(paragraphRef, selectedCommentaries);

            // ×©×œ×•×£ ×’×™×¨×¡××•×ª × ×•×¡×¤×•×ª - ×‘×××¦×¢×•×ª ×’×™×©×” ×™×¢×™×œ×” ×™×•×ª×¨
            const additionalVersions = await this.fetchAdditionalVersionsEfficient(paragraphRef, selectedVersions, arrayIndex);

            documentData.push({
                paragraphNum: index,
                ref: paragraphRef,
                hebrewText: cleanText,
                additionalVersions,
                commentaries
            });

            this.log(`âœ… Added paragraph ${index} with ${commentaries.length} commentaries`);

        } catch (error) {
            this.log(`âŒ Error processing paragraph ${index}: ${error.message}`, 'error');
        }

        // ×”×©×”×™×” ×§×¦×¨×” ×‘×™×Ÿ ×‘×§×©×•×ª
        await new Promise(resolve => setTimeout(resolve, 100));
    }

    this.log(`ğŸ‰ Document data ready: ${documentData.length} paragraphs`);
    return documentData;
}
async fetchAdditionalVersionsEfficient(ref, selectedVersions, arrayIndex) {
    if (!selectedVersions || selectedVersions.length === 0) {
        return [];
    }

    this.log(`ğŸ“š Fetching additional versions for: ${ref}`);
    const versions = [];

    for (const version of selectedVersions) {
        try {
            // ×•×“× ×©×™×© ×œ× ×• title ×•-language ×ª×§×™× ×™×
            if (!version.title || !version.language) {
                this.log(`âš ï¸ Skipping invalid version:`, version);
                continue;
            }
            
            this.log(`ğŸ” Fetching version: ${version.title} (${version.language})`);
            
            // ×™×¦×™×¨×ª ××¤×ª×— ××˜××•×Ÿ ×œ×’×¨×¡×” ×–×•
            const cacheKey = `${this.currentChapter}_${version.title}`;
            
            // ×‘×“×™×§×” ×× ×™×© ×œ× ×• ×›×‘×¨ ××ª ×›×œ ×”×¤×¨×§ ×‘××˜××•×Ÿ
            let versionChapterData = this.commentaryCache.get(cacheKey);
            
            if (!versionChapterData) {
                // ×× ××™×Ÿ ×‘××˜××•×Ÿ, × ×˜×¢×Ÿ ××ª ×›×œ ×”×¤×¨×§
                const chapterRef = ref.split(':')[0]; // ×œ×§×‘×œ ×¨×§ ××ª ×”×”×¤× ×™×” ×œ×¤×¨×§ ×œ×œ× ××¡×¤×¨ ×¤×¡×•×§
                const encodedRef = encodeURIComponent(chapterRef);
                const versionParam = encodeURIComponent(`${version.language}|${version.title}`);
                const url = `${this.baseUrl}/v3/texts/${encodedRef}?version=${versionParam}`;
                
                this.log(`ğŸŒ Version URL for whole chapter: ${url}`);
                
                const response = await fetch(url);
                
                if (response.ok) {
                    versionChapterData = await response.json();
                    this.log(`ğŸ“Š Version chapter data for ${version.title}:`, versionChapterData);
                    
                    // ×©××•×¨ ×‘××˜××•×Ÿ ×œ×©×™××•×© ×¢×ª×™×“×™
                    this.commentaryCache.set(cacheKey, versionChapterData);
                } else {
                    this.log(`âŒ Failed to fetch version ${version.title}: ${response.status}`);
                    continue;
                }
            } else {
                this.log(`ğŸ“‹ Using cached chapter data for version: ${version.title}`);
            }
            
            // ×—×œ×¥ ××ª ×”×˜×§×¡×˜ ×”×¡×¤×¦×™×¤×™ ×œ×¤×¡×•×§/×¤×™×¡×§× ×× ×ª×•× ×™ ×”×¤×¨×§ ×‘×”×ª×× ×œ×©×¤×”
            let versionText = '';
                versionText = versionChapterData.versions[0].text[arrayIndex];
                        this.log(`ğŸ“„ Found ${version.text} text for ${version.title} `);
      
            if (!versionText) {
                this.log(`âš ï¸ No text found for version ${version.title} at index ${arrayIndex}`);
                continue;
            }
            
            if (versionText && versionText.trim()) {
                // × ×§×” ×-HTML tags
                versionText = versionText.replace(/<[^>]*>/g, '').trim();
                
                versions.push({
                    title: version.title,
                    heTitle: versionChapterData.versions[0].versionTitleInHebrew || '',
                    heRef: version.heRef || '',
                    language: version.language,
                    text: versionText
                });
                
                this.log(`âœ… Added version: ${version.title} (${versionText.length} chars)`);
            } else {
                this.log(`âš ï¸ No text found for version ${version.title} at index ${arrayIndex}`);
                
                // ×× ×œ× ×”×¦×œ×—× ×• ×œ××¦×•× ×˜×§×¡×˜ ×¡×¤×¦×™×¤×™, × × ×¡×” ××ª ×”×©×™×˜×” ×”×™×©× ×”
                await this.fetchVersionFallback(ref, version, versions);
            }
            
        } catch (error) {
            this.log(`âŒ Error fetching version ${version.title}: ${error.message}`, 'error');
            
            // × ×¡×” fallback ×‘××§×¨×” ×©×œ ×©×’×™××”
            await this.fetchVersionFallback(ref, version, versions);
        }
    }

    this.log(`ğŸ“š Fetched ${versions.length} additional versions`);
    return versions;
}
            async fetchCommentariesForParagraph(ref, selectedCommentaries) {
                if (selectedCommentaries.length === 0) return [];

                try {
                    this.log(`ğŸ“ Fetching commentaries for: ${ref}`);

                    const response = await fetch(`${this.baseUrl}/links/${encodeURIComponent(ref)}`);
                    const links = await response.json();


                    const commentaries = [];

                    if (Array.isArray(links)) {
                        for (const link of links) {
                            if (link.category === 'Commentary' && link.collectiveTitle) {
                                const commentaryTitle = link.collectiveTitle.he || link.collectiveTitle.en;

                                if (selectedCommentaries.includes(commentaryTitle)) {
                                    this.log(`ğŸ” Processing commentary: ${commentaryTitle} -> ${link.sourceRef}`);

                                    // ×©×œ×•×£ ××ª ×˜×§×¡×˜ ×”×¤×™×¨×•×© ×‘××•×¤×Ÿ ×—×›× ×™×•×ª×¨
                                    const commentaryText = await this.fetchCommentaryTextSmart(link.sourceRef, ref);
                                    if (commentaryText) {
                                        commentaries.push({
                                            title: commentaryTitle,
                                            text: commentaryText,
                                            ref: link.sourceRef
                                        });
                                        this.log(`âœ… Added commentary: ${commentaryTitle} (${commentaryText.length} chars)`);
                                    }
                                }
                            }
                        }
                    }

                    return commentaries;
                } catch (error) {
                    this.log(`âŒ Error fetching commentaries for ${ref}: ${error.message}`, 'error');
                    return [];
                }
            }

            async fetchCommentaryTextSmart(commentaryRef, originalRef) {
                try {
                    this.log(`ğŸ“– Fetching commentary smartly: ${commentaryRef}`);

                    // ×¤×¨×§ ××ª ×”×”×¤× ×™×” ×œ×–×™×”×•×™ ×”×¤×™×¡×§× ×”×¡×¤×¦×™×¤×™×ª
                    const { baseRef, paragraphNum } = this.parseCommentaryRef(commentaryRef, originalRef);

                    this.log(`ğŸ” Parsed: baseRef=${baseRef}, paragraphNum=${paragraphNum}`);

                    // ×©×œ×•×£ ××ª ×›×œ ×”×¤×™×¨×•×© (×”×“×£/×¤×¨×§) ×‘×‘×ª ××—×ª
                    const response = await fetch(`${this.baseUrl}/texts/${encodeURIComponent(baseRef)}`);
                    const data = await response.json();

                    this.log(`ğŸ“Š Commentary data for ${baseRef}:`, data);

                    // ×—×œ×¥ ××ª ×”×˜×§×¡×˜ ×”×¡×¤×¦×™×¤×™ ××”××¢×¨×š
                    let text = '';

                    if (data.he && Array.isArray(data.he) && paragraphNum !== null) {
                        // ×™×© ××¢×¨×š ×•×× ×—× ×• ×™×•×“×¢×™× ××™×–×” ×¤×™×¡×§×
                        const paragraphIndex = paragraphNum - 1;
                        if (paragraphIndex >= 0 && paragraphIndex < data.he.length) {
                            text = data.he[paragraphIndex];
                            this.log(`âœ… Found specific paragraph ${paragraphNum}: ${text.substring(0, 100)}...`);
                        } else {
                            this.log(`âŒ Paragraph ${paragraphNum} not found in array of ${data.he.length} items`);
                        }
                    } else if (data.he) {
                        // ×× ××™×Ÿ ××¢×¨×š ××• ×œ× ×™×•×“×¢×™× ××ª ×”××¡×¤×¨, ×§×— ××ª ×”×›×œ
                        if (Array.isArray(data.he)) {
                            text = data.he.join(' ');
                        } else {
                            text = data.he;
                        }
                        this.log(`ğŸ“„ Using full commentary text (${text.length} chars)`);
                    } else if (data.text) {
                        if (Array.isArray(data.text)) {
                            text = data.text.join(' ');
                        } else {
                            text = data.text;
                        }
                    }

                    // × ×§×” ××ª ×”×˜×§×¡×˜ ×-HTML tags
                    if (text) {
                        text = text.replace(/<[^>]*>/g, '').trim();
                    }

                    this.log(`ğŸ“ Final commentary text (${text.length} chars): ${text.substring(0, 100)}...`);
                    return text;

                } catch (error) {
                    this.log(`âŒ Error fetching commentary text: ${error.message}`, 'error');
                    return '';
                }
            }

            parseCommentaryRef(commentaryRef, originalRef) {
                // × ×¡×” ×œ×¤×¨×§ ××ª ×”×”×¤× ×™×” ×œ××¦×™××ª ×”×¤×™×¡×§× ×”×¨×œ×•×•× ×˜×™×ª
                try {
                    // ×“×•×’××: "Mikdash Melekh on Zohar 1:1a:1" -> baseRef="Mikdash Melekh on Zohar 1:1a", paragraphNum=1
                    const parts = commentaryRef.split(':');

                    if (parts.length >= 3) {
                        // ×™×© ××¡×¤×¨ ×¤×™×¡×§× ×‘××—×¨×•×Ÿ
                        const paragraphNum = parseInt(parts[parts.length - 1]);
                        const baseRef = parts.slice(0, -1).join(':');

                        if (!isNaN(paragraphNum)) {
                            return { baseRef, paragraphNum };
                        }
                    }

                    // ×× ×œ× ×”×¦×œ×—× ×• ×œ×¤×¨×§, × ×—×–×™×¨ ××ª ×›×œ ×”×”×¤× ×™×” ×›-baseRef
                    return { baseRef: commentaryRef, paragraphNum: null };

                } catch (error) {
                    this.log(`âŒ Error parsing commentary ref: ${error.message}`);
                    return { baseRef: commentaryRef, paragraphNum: null };
                }
            }

            async fetchAdditionalVersions(ref, selectedVersions) {
                if (!selectedVersions || selectedVersions.length === 0) {
                    return [];
                }

                this.log(`ğŸ“š Fetching additional versions for: ${ref}`);
                const versions = [];

                for (const version of selectedVersions) {
                    try {
                        // ×•×“× ×©×™×© ×œ× ×• title ×•-language ×ª×§×™× ×™×
                        if (!version.title || !version.language) {
                            this.log(`âš ï¸ Skipping invalid version:`, version);
                            continue;
                        }

                        this.log(`ğŸ” Fetching version: ${version.title} (${version.language})`);

                        // ×”×©×ª××© ×‘-API v3 ×¢× ×¤×¨××˜×¨ version ×‘×¤×•×¨××˜ ×”× ×›×•×Ÿ: language|versionTitle
                        const encodedRef = encodeURIComponent(ref);
                        const versionParam = encodeURIComponent(`${version.language}|${version.title}`);
                        const url = `${this.baseUrl}/v3/texts/${encodedRef}?version=${versionParam}`;

                        this.log(`ğŸŒ Version URL: ${url}`);

                        const response = await fetch(url);

                        if (response.ok) {
                            const versionData = await response.json();

                            let versionText = '';
                            console.log(versionData, "versionData");
                            
                            // × ×¡×” ×œ×—×œ×¥ ××ª ×”×˜×§×¡×˜ ××”×’×™×¨×¡×”
                            if (versionData.versions && versionData.versions.length > 0) {
                                // API v3 ××—×–×™×¨ versions array
                                const versionInfo = versionData.versions.find(v => v.versionTitle === version.title) ||
                                    versionData.versions.find(v => v.language === version.language) ||
                                    versionData.versions[0];

                                if (versionInfo && versionInfo.text) {
                                    if (Array.isArray(versionInfo.text)) {
                                        versionText = versionInfo.text[0] || '';
                                    } else {
                                        versionText = versionInfo.text;
                                    }
                                }
                            } else if (versionData.text) {
                                // fallback ×œ×¤×•×¨××˜ ×™×©×Ÿ
                                if (Array.isArray(versionData.text)) {
                                    versionText = versionData.text[0] || '';
                                } else {
                                    versionText = versionData.text;
                                }
                            } else if (versionData.he) {
                                if (Array.isArray(versionData.he)) {
                                    versionText = versionData.he[0] || '';
                                } else {
                                    versionText = versionData.he;
                                }
                            } else if (versionData.en) {
                                if (Array.isArray(versionData.en)) {
                                    versionText = versionData.en[0] || '';
                                } else {
                                    versionText = versionData.en;
                                }
                            }

                            if (versionText && versionText.trim()) {
                                // × ×§×” ×-HTML tags
                                versionText = versionText.replace(/<[^>]*>/g, '').trim();

                                versions.push({
                                    title: version.title,
                                    heTitle: version.HeTile,
                                    heRef: version.heRef,
                                    language: version.language,
                                    text: versionText
                                });

                                this.log(`âœ… Added version: ${version.title} (${versionText.length} chars)`);
                            } else {
                                this.log(`âš ï¸ No text found for version2: ${version.title}`);
                            }
                        } else {
                            this.log(`âŒ Failed to fetch version ${version.title}: ${response.status}`);

                            // × ×¡×” fallback ×¢× API ×¨×’×™×œ
                            await this.fetchVersionFallback(ref, version, versions);
                        }

                        // ×”×©×”×™×” ×§×¦×¨×” ×‘×™×Ÿ ×‘×§×©×•×ª
                        await new Promise(resolve => setTimeout(resolve, 100));

                    } catch (error) {
                        this.log(`âŒ Error fetching version ${version.title}: ${error.message}`, 'error');

                        // × ×¡×” fallback ×‘××§×¨×” ×©×œ ×©×’×™××”
                        await this.fetchVersionFallback(ref, version, versions);
                    }
                }

                this.log(`ğŸ“š Fetched ${versions.length} additional versions`);
                return versions;
            }

            async fetchVersionFallback(ref, version, versions) {
                try {
                    this.log(`ğŸ”„ Trying fallback for version: ${version.title}`);

                    // × ×¡×” ×¢× API ×¨×’×™×œ ×¢× ×¤×¨××˜×¨ version
                    const versionParam = encodeURIComponent(`${version.language}|${version.title}`);
                    const url = `${this.baseUrl}/v3/texts/${encodeURIComponent(ref)}?version=${versionParam}`;

                    this.log(`ğŸŒ Fallback URL: ${url}`);

                    const response = await fetch(url);

                    if (response.ok) {
                        const versionData = await response.json();

                        let versionText = '';

                        if (versionData.text && Array.isArray(versionData.text) && versionData.text.length > 0) {
                            versionText = versionData.text[0];
                        } else if (versionData.text) {
                            versionText = versionData.text;
                        } else if (versionData.he && Array.isArray(versionData.he) && versionData.he.length > 0) {
                            versionText = versionData.he[0];
                        } else if (versionData.he) {
                            versionText = versionData.he;
                        } else if (versionData.en && Array.isArray(versionData.en) && versionData.en.length > 0) {
                            versionText = versionData.en[0];
                        } else if (versionData.en) {
                            versionText = versionData.en;
                        }

                        if (versionText && versionText.trim()) {
                            versionText = versionText.replace(/<[^>]*>/g, '').trim();

                            // ×‘×“×•×§ ×× ×¢×•×“ ×œ× ×”×•×¡×¤× ×• ××ª ×”×’×™×¨×¡×” ×”×–×•
                            const existingVersion = versions.find(v => v.title === version.title);
                            if (!existingVersion) {
                                versions.push({
                                    title: version.title,
                                    language: version.language,
                                    text: versionText
                                });

                                this.log(`âœ… Fallback success: ${version.title} (${versionText.length} chars)`);
                            }
                        } else {
                            this.log(`âš ï¸ Fallback: No text found for ${version.title}`);
                        }
                    } else {
                        this.log(`âŒ Fallback also failed: ${response.status}`);
                    }

                } catch (error) {
                    this.log(`âŒ Fallback error: ${error.message}`, 'error');
                }
            }

            createWordDocument(documentData) {
                let html = `
                <!DOCTYPE html>
                <html dir="rtl" lang="he">
                <head>
                    <meta charset="UTF-8">
                    <style>
                        body { 
                            font-family: 'David', 'Times New Roman', serif; 
                            direction: rtl; 
                            text-align: right;
                            line-height: 1.8;
                            margin: 0.8cm;
                        }
                        .main-title { 
                            font-size: 24px; 
                            font-weight: bold; 
                            text-align: center; 
                            margin-bottom: 30px;
                            border-bottom: 2px solid #333;
                            padding-bottom: 10px;
                        }
                        .paragraph-container { 
                            margin-bottom: 30px; 
                            padding: 15px;
                            border: 1px solid #ddd;
                            border-radius: 5px;
                        }
                        .paragraph-header { 
                            font-size: 14px; 
                            font-weight: bold; 
                            color: #666;
                            margin-bottom: 10px;
                            background-color: #f0f0f0;
                            padding: 5px 10px;
                            border-radius: 3px;
                        }
                        .paragraph-text { 
                            font-size: 16px; 
                            font-weight: bold; 
                            margin-bottom: 15px;
                            line-height: 1.6;
                        }
                        .additional-versions-section {
                            margin-top: 15px;
                            padding-top: 10px;
                            border-top: 1px solid #e0e0e0;
                        }
                        .additional-version {
                            margin: 10px 0;
                            padding: 10px;
                            background-color: #f0f8ff;
                            border-right: 3px solid #4682b4;
                            border-radius: 3px;
                        }
                        .version-title {
                            font-weight: bold;
                            color: #4682b4;
                            margin-bottom: 5px;
                            font-size: 14px;
                        }
                        .version-text {
                            font-size: 15px;
                            color: #2c3e50;
                            line-height: 1.5;
                        }
                        .commentary-section {
                            margin-top: 15px;
                            padding-top: 10px;
                            border-top: 1px dashed #ccc;
                        }
                        .commentary-title { 
                            font-size: 14px; 
                            font-weight: bold; 
                            color: #8e44ad;
                            margin-bottom: 5px;
                        }
                        .commentary-text { 
                            font-size: 13px; 
                            color: #555;
                            margin-bottom: 10px;
                            padding: 8px;
                            background-color: #fafafa;
                            border-right: 3px solid #8e44ad;
                        }
                    </style>
                </head>
                <body>
                `;

                // ×›×•×ª×¨×ª ×¨××©×™×ª
                let title = this.chapterInfo.heSectionRef || this.chapterInfo.heTitle;

                html += `<h1 class="main-title">${title}</h1>`;

                // ×”×•×¡×¤×ª ×›×œ ×”×¤×™×¡×§××•×ª
                documentData.forEach(paragraph => {
                    html += `
                    <div class="paragraph-container">
                        <div class="paragraph-header">${paragraph.heTitle || paragraph.ref}</div>
                        <div class="paragraph-text">${paragraph.hebrewText}</div>
                    `;

                    // ×”×•×¡×¤×ª ×’×™×¨×¡××•×ª × ×•×¡×¤×•×ª
                    if (paragraph.additionalVersions && paragraph.additionalVersions.length > 0) {
                        html += `<div class="additional-versions-section">`;
                        paragraph.additionalVersions.forEach(version => {
                            html += `
                            <div class="additional-version">
                                <div class="version-title">${version.title} (${version.language})</div>
                                <div class="version-text">${version.text}</div>
                            </div>
                            `;
                        });
                        html += `</div>`;
                    }

                    // ×”×•×¡×¤×ª ×¤×™×¨×•×©×™×
                    if (paragraph.commentaries && paragraph.commentaries.length > 0) {
                        html += `<div class="commentary-section">`;
                        paragraph.commentaries.forEach(commentary => {
                            html += `
                            <div class="commentary-title">${commentary.title}</div>
                            <div class="commentary-text">${commentary.text}</div>
                            `;
                        });
                        html += `</div>`;
                    }

                    html += `</div>`;
                });

                html += `</body></html>`;

                // ×”×•×¨×“×ª ×”×§×•×‘×¥
                const blob = new Blob([html], { type: 'application/msword' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${title.replace(/[^\u0590-\u05FF\w\s-]/g, '')}.doc`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            async loadCommentaries() {
                try {
                    this.log('ğŸ“ Loading commentaries...');
                    const start = document.getElementById('startParagraph').value;

                    if (!start) {
                        document.getElementById('commentariesContainer').innerHTML = '<div>×‘×—×¨ ×¤×™×¡×§××•×ª ×ª×—×™×œ×”</div>';
                        return;
                    }

                    // ×‘× ×” ×”×¤× ×™×” ×œ×¤×™×¡×§× ×¨××©×•× ×” ×›×“×•×’××”
                    let sampleRef;
                    if (this.currentSection) {
                        sampleRef = `${this.currentBook.title}, ${this.currentSection.key} ${this.currentChapter}:${start}`;
                    } else {
                        sampleRef = `${this.currentBook.title} ${this.currentChapter}:${start}`;
                    }

                    this.log(`ğŸ”— Sample commentary reference: ${sampleRef}`);

                    // × ×¡×” ××¡×¤×¨ ×“×¨×›×™× ×œ××¦×•× ××¤×¨×©×™×
                    const commentaries = await this.discoverCommentaries(sampleRef);

                    const container = document.getElementById('commentariesContainer');
                    container.innerHTML = '';

                    if (commentaries.size > 0) {
                        commentaries.forEach(title => {
                            const label = document.createElement('label');
                            const checkbox = document.createElement('input');
                            checkbox.type = 'checkbox';
                            checkbox.value = title;

                            label.appendChild(checkbox);
                            label.appendChild(document.createTextNode(title));
                            container.appendChild(label);
                        });

                        this.log(`âœ… Found ${commentaries.size} commentaries`);
                    } else {
                        container.innerHTML = '<div>×œ× × ××¦××• ××¤×¨×©×™× ×–××™× ×™×</div>';
                        this.log('âŒ No commentaries found');
                    }
                } catch (error) {
                    this.log(`âŒ Error loading commentaries: ${error.message}`, 'error');
                    document.getElementById('commentariesContainer').innerHTML = '<div>×©×’×™××” ×‘×˜×¢×™× ×ª ××¤×¨×©×™×</div>';
                }
            }

            async discoverCommentaries(ref) {
                const commentaries = new Set();

                // ×©×™×˜×” 1: ×©×œ×•×£ ×§×™×©×•×¨×™× ×™×©×™×¨×™×
                try {
                    const response = await fetch(`${this.baseUrl}/links/${encodeURIComponent(ref)}`);

                    if (response.ok) {
                        const links = await response.json();

                        if (Array.isArray(links)) {
                            links.forEach(link => {
                                if (link.category === 'Commentary' && link.collectiveTitle) {
                                    const title = link.collectiveTitle.he || link.collectiveTitle.en;
                                    if (title) {
                                        commentaries.add(title);
                                        this.log(`ğŸ“ Found commentary: ${title}`);
                                    }
                                }
                            });
                        }
                    }
                } catch (error) {
                    this.log(`âŒ Error fetching links: ${error.message}`);
                }

                if (commentaries.size === 0) {
                    this.log('ğŸ” No links found, trying known commentaries');
                }

                return commentaries;
            }

            updateBreadcrumb() {
                const breadcrumb = document.getElementById('breadcrumb');
                let path = 'ğŸ“ ×“×£ ×”×‘×™×ª';

                this.currentPath.forEach(item => {
                    if (item.category) {
                        path += ` > ${item.heCategory || item.category}`;
                    } else if (item.title) {
                        path += ` > ${item.heTitle || item.title}`;
                    }
                });

                breadcrumb.textContent = path;
            }

            updateBackButton() {
                document.getElementById('backBtn').disabled = this.currentPath.length === 0;
            }

            // ×¤×•× ×§×¦×™×•×ª ×¢×–×¨
            log(message, data = null, type = 'info') {
                const debugPanel = document.getElementById('debugPanel');
                const timestamp = new Date().toLocaleTimeString();

                let logEntry = `[${timestamp}] ${message}`;
                if (data) {
                    logEntry += '\n' + JSON.stringify(data, null, 2);
                }

                const logDiv = document.createElement('div');
                logDiv.style.color = type === 'error' ? '#ff6b6b' : type === 'success' ? '#51cf66' : '#74c0fc';
                logDiv.style.marginBottom = '5px';
                logDiv.textContent = logEntry;

                debugPanel.appendChild(logDiv);
                debugPanel.scrollTop = debugPanel.scrollHeight;

                console.log(message, data);
            }

            clearDebug() {
                document.getElementById('debugPanel').innerHTML = '<div>ğŸ“± Debug cleared</div>';
            }

            showError(message) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error';
                errorDiv.textContent = message;
                document.body.appendChild(errorDiv);

                setTimeout(() => {
                    if (errorDiv.parentNode) {
                        errorDiv.parentNode.removeChild(errorDiv);
                    }
                }, 5000);
            }

            showSuccess(message) {
                const successDiv = document.createElement('div');
                successDiv.className = 'success';
                successDiv.textContent = message;
                document.body.appendChild(successDiv);

                setTimeout(() => {
                    if (successDiv.parentNode) {
                        successDiv.parentNode.removeChild(successDiv);
                    }
                }, 5000);
            }
        }

        // ×”×ª×—×œ×ª ×”××¤×œ×™×§×¦×™×”
        document.addEventListener('DOMContentLoaded', () => {
            new SefariaNavigator();
        });
    </script>
</body>

</html>